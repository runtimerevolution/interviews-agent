export const questions = [
  {
    "id": 1,
    "category": "Basic Ruby",
    "level": "junior",
    "title": "== vs equal?",
    "question": "Explain the difference between '==' and 'equal?' in Ruby.",
    "correctAnswer": "'==' checks for value equality (can be overridden), while 'equal?' checks for object identity (same object in memory). For example, two strings with the same content are == but not equal? unless they're the same object.",
    "codeExample": "a = \"hello\"\nb = \"hello\"\nc = a\n\n# Value equality (content comparison)\na == b        # => true\n\n# Object identity (same object in memory)\na.equal?(b)   # => false\na.equal?(c)   # => true\n\n# With numbers (integers are cached)\nx = 5\ny = 5\nx == y        # => true\nx.equal?(y)   # => true (small integers reuse same object)",
  },
  {
    "id": 2,
    "category": "Object-Oriented Programming (OOP)",
    "level": "junior",
    "title": "Instance vs Local Variable Scope",
    "question": "Look at the code example below. Explain what `@name` is and what `name` (without the @ symbol) is inside the `introduce` method. What will this code print out and why?",
    "correctAnswer": "`@name` is an instance variable, meaning it is accessible throughout the entire instance of the class. `name` (inside the `introduce` method) is a local variable, only available within that specific method scope. The code will print 'Hello, Alice. My name is Stranger.' because the second string interpolation uses the local variable `name` ('Stranger'), not the instance variable.",
    "codeExample": "class Person\n  def initialize(name_passed_in)\n    @name = name_passed_in # Instance variable\n  end\n\n  def introduce\n    name = \"Stranger\" # Local variable\n    puts \"Hello, #{@name}. My name is #{name}.\"\n  end\nend\n\np = Person.new(\"Alice\")\np.introduce\n# Output: Hello, Alice. My name is Stranger."
  },
  {
    "id": 3,
    "category": "Practical Coding / Hashes",
    "level": "junior",
    "title": "Summing Hash Values",
    "question": "Given a hash representing a cart where keys are item names (symbols) and values are prices (integers), write code to calculate the total cost. Bonus points if you can do it in one line using built-in methods.",
    "correctAnswer": "A basic answer will iterate over the hash using `.each` and add values to an accumulator variable. A strong junior answer will know how to access just the values of the hash and use an enumerable method like `.sum` (Ruby 2.4+) or `.reduce(:+)` to calculate the total in a functional style.",
    "codeExample": "cart = { apple: 1, banana: 2, steak: 15, pasta: 5 }\n\n# Approach 1: Iteration\ntotal = 0\ncart.each { |item, price| total += price }\n\n# Approach 2 (Idiomatic/Bonus): Using .sum\ntotal_sum = cart.values.sum\n\n# Approach 3 (Functional): Using reduce/inject\ntotal_reduce = cart.values.reduce(:+)"
  },
  {
    "id": 4,
    "category": "Rails Fundamentals",
    "level": "junior",
    "title": "Convention over Configuration",
    "question": "One of Rails' main philosophies is 'Convention over Configuration'. Can you give a simple example of what this means in practice?",
    "correctAnswer": "It means Rails makes assumptions about what you want to do based on naming conventions, saving you from writing config files. For example, if you create a model named `Post` (singular), Rails automatically assumes the corresponding database table is named `posts` (plural), and the controller is `PostsController`.",
    "codeExample": "# Because I named this class 'Article'...\nclass Article < ApplicationRecord\nend\n\n# ...Rails automatically knows to look into a DB table named 'articles'.\n# I don't have to configure it like: set_table_name = 'my_articles_table'"
  },
  {
    "id": 5,
    "category": "Active Record / Validations",
    "level": "junior",
    "title": "Active Record Validations",
    "question": "Where do validations (like ensuring an email field isn't empty) typically live in a Rails app, and at what point in the object lifecycle do they run?",
    "correctAnswer": "Validations live in the Model file. They run when you try to persist data to the database, typically when calling methods like `.save`, `.create`, or `.update`. If validations fail, these methods return `false` and the data is not saved to the database.",
    "codeExample": "# app/models/user.rb\nclass User < ApplicationRecord\n  # These run before .save attempts the DB insert\n  validates :username, presence: true\n  validates :email, presence: true, uniqueness: true\nend\n\nuser = User.new(username: \"test\")\nuser.save # => false (because email is missing)\nuser.errors.full_messages # => [\"Email can't be blank\"]"
  },
  {
    "id": 6,
    "category": "Active Record / Performance",
    "level": "senior",
    "title": "Eager Loading and N+1 Problem",
    "question": "Explain the 'N+1 query problem' in Active Record, how it manifests, and detail at least three different strategies or methods Rails provides to mitigate or resolve it, including their pros and cons.",
    "correctAnswer": "The N+1 problem occurs when fetching a collection of records (the '1' query) and then iterating over them, causing an additional query ('N' queries) for each record to fetch an associated record. It typically manifests as many identical `SELECT` queries for associations. \n\nStrategies:\n1.  **`includes` (eager loading):** Loads all associations in a minimal number of queries (often 1 or 2 using `LEFT OUTER JOIN` or separate `SELECT`s). Best for frequent association access. Pros: Simple, often optimal. Cons: Can fetch more data than needed, potential performance hit if associated data is large and not always used.\n2.  **`eager_load`:** Similar to `includes`, but strictly uses `LEFT OUTER JOIN`. Useful when you need to filter or order by associated attributes. Pros: Allows filtering/ordering on joined tables. Cons: Can lead to large intermediate result sets if associations are large.\n3.  **`joins`:** Performs an `INNER JOIN` but *does not* eager load the associated objects. Used when you only need to filter or sort based on associations, not access them directly. Pros: Efficient for filtering. Cons: Does not solve the N+1 problem for accessing associations; can return duplicate parent records if the association has multiple children.\n4.  **`preload`:** Forces separate `SELECT` queries for associations, similar to `includes` when `includes` decides against a join. Useful when `includes` causes issues with complex joins. Pros: Avoids large intermediate result sets from `LEFT JOIN`s. Cons: Performs multiple queries.",
    "codeExample": "class Author < ApplicationRecord\n  has_many :books\nend\nclass Book < ApplicationRecord; end\n\n# N+1 Problem:\nauthors = Author.all # 1 query\nauthors.each do |author|\n  puts author.books.count # N queries (one for each author)\nend\n\n# Solution with `includes`:\nauthors = Author.includes(:books).all # 2 queries (or 1 join)\nauthors.each do |author|\n  puts author.books.count # No extra queries\nend"
  },
  {
    "id": 7,
    "category": "Active Record / Transactions",
    "level": "senior",
    "title": "Database Transactions in Rails",
    "question": "When and why would you use `ActiveRecord::Base.transaction`? Describe its behavior, including how it handles exceptions and nested transactions.",
    "correctAnswer": "Transactions ensure atomicity: a series of database operations either all succeed or all fail, leaving the database in a consistent state. You use them when multiple dependent operations must be treated as a single unit (e.g., transferring money, creating an order with multiple line items). If any operation within the transaction fails or an exception is raised, all previous changes within that transaction are rolled back.\n\nBehavior:\n-   **Exceptions:** If an `ActiveRecord::Rollback` exception is raised, the transaction is rolled back, but other exceptions propagate normally. If any other exception occurs, the transaction is rolled back and the exception is re-raised.\n-   **Nested Transactions:** By default, Rails transactions don't truly nest in the database; they typically use savepoints. Only the outermost `transaction` block truly commits or rolls back to the initial state. An inner `transaction` block will create a savepoint and `ROLLBACK TO SAVEPOINT` if it fails, but the entire transaction won't be committed until the outermost block succeeds.",
    "codeExample": "ActiveRecord::Base.transaction do\n  user = User.create!(name: 'New User')\n  account = Account.create!(user: user, balance: 100)\n\n  # If this fails, both user and account creation will be rolled back\n  TransactionRecord.create!(from_account: nil, to_account: account, amount: 50)\nend\n\n# Nested Transaction Example (simplified)\nActiveRecord::Base.transaction do\n  # Outer transaction starts\n  Project.create!(name: 'Main Project')\n\n  ActiveRecord::Base.transaction do\n    # Inner transaction (often a savepoint)\n    Task.create!(name: 'Task 1', project_id: 1) # Assumed project_id exists\n    raise ActiveRecord::Rollback # Rolls back to this savepoint, but outer is still active\n  end\n\n  # Project 'Main Project' will still be committed if no other errors occur\n  puts 'Outer transaction continues'\nend"
  },
  {
    "id": 8,
    "category": "Active Record / Callbacks",
    "level": "senior",
    "title": "Advanced Callbacks and Side Effects",
    "question": "Discuss the pros and cons of using Active Record callbacks (e.g., `after_save`, `before_validation`). When might you choose to avoid them, and what are common alternatives for handling complex side effects or business logic?",
    "correctAnswer": "Pros:\n-   **Encapsulation:** Keep model-related logic within the model, promoting DRY.\n-   **Automatic Execution:** Ensures certain actions always happen at specific points in an object's lifecycle.\n-   **Readability (simple cases):** Can make simple actions easy to understand.\n\nCons:\n-   **Hidden Logic:** Can lead to 'magic' where behavior is not obvious from method calls, making debugging harder.\n-   **Order Dependency:** Unpredictable order in complex chains, especially across associations.\n-   **Performance:** Can inadvertently run heavy operations on every save.\n-   **Testing Difficulty:** Harder to test in isolation without triggering unwanted side effects.\n-   **Reusability:** Callbacks are tightly coupled to the model's persistence, not easily reusable in other contexts.\n\nAvoid them when:\n-   The logic is not directly related to the model's state persistence (e.g., sending emails).\n-   The logic is complex, involves multiple models, or has significant side effects.\n-   The logic might be triggered multiple times unnecessarily.\n\nAlternatives:\n1.  **Service Objects:** Encapsulate complex business logic in plain Ruby objects. They take specific inputs, perform actions, and return results. Explicit and testable.\n2.  **Form Objects:** For handling complex form submissions, aggregation of data from multiple models.\n3.  **Command/Operation Objects:** Similar to service objects but often for a single, well-defined action.\n4.  **Event-Driven Architecture:** Publish events (`UserCreated`, `OrderPlaced`) and have other parts of the system subscribe and react to these events (e.g., using a background job system or dedicated event bus).",
    "codeExample": "# Problematic Callback:\nclass Order < ApplicationRecord\n  after_create :send_confirmation_email\n  # This sends an email on every order creation, even in tests or admin seed scripts.\n  # It's also a slow operation that blocks the request.\nend\n\n# Better with a Service Object or Background Job:\nclass OrdersController < ApplicationController\n  def create\n    @order = Order.new(order_params)\n    if @order.save\n      # Explicitly call a service or enqueue a job\n      OrderConfirmationMailer.with(order: @order).confirmation_email.deliver_later\n      redirect_to @order, notice: 'Order placed!'\n    else\n      render :new\n    end\n  end\nend"
  },
  {
    "id": 9,
    "category": "Active Record / Querying",
    "level": "senior",
    "title": "Advanced Filtering and Subqueries",
    "question": "You have `User` records and `Order` records, where a User `has_many :orders`. Write an Active Record query to find all users who have placed *at least five orders* and *whose most recent order was placed within the last 30 days*. Explain the components of your query.",
    "correctAnswer": "```ruby\nUser.joins(:orders)\n    .group('users.id')\n    .having('COUNT(orders.id) >= 5')\n    .where('orders.created_at >= ?', 30.days.ago)\n    .distinct\n    .order('MAX(orders.created_at) DESC') # Optional: order by most recent order date\n```\n\n**Components Explanation:**\n-   **`User.joins(:orders)`:** Performs an `INNER JOIN` with the `orders` table. This is crucial for accessing order data.\n-   **`.group('users.id')`:** Groups the results by `user.id`. This allows us to apply aggregate functions (like `COUNT` and `MAX`) to each user's orders.\n-   **`.having('COUNT(orders.id) >= 5')`:** Filters the *grouped results* (users) to include only those who have a count of 5 or more orders. `HAVING` is used for filtering on aggregate functions, whereas `WHERE` is for individual rows.\n-   **`.where('orders.created_at >= ?', 30.days.ago)`:** Filters the *individual order records* before grouping, ensuring we only consider recent orders. If we put this in `HAVING`, it would apply to the max `created_at` after grouping.\n-   **`.distinct`:** Ensures that each user is returned only once, even if they have multiple orders that satisfy the criteria (important because of the `joins`).\n-   **`.order('MAX(orders.created_at) DESC')` (Optional):** Orders the final user list by the `created_at` date of their most recent order.",
    "codeExample": "class User < ApplicationRecord\n  has_many :orders\nend\nclass Order < ApplicationRecord\n  belongs_to :user\nend\n\n# The query:\nactive_high_volume_users = User.joins(:orders)\n                               .group('users.id')\n                               .having('COUNT(orders.id) >= ?', 5)\n                               .where('orders.created_at >= ?', 30.days.ago)\n                               .distinct\n\n# Example usage:\n# active_high_volume_users.each { |user| puts user.name }"
  },
  {
    "id": 10,
    "category": "Active Record / SQL & AREL",
    "level": "senior",
    "title": "Dropping to AREL or Raw SQL",
    "question": "When would a senior developer choose to drop down from standard Active Record query methods to use AREL directly, or even raw SQL, and what are the associated risks and benefits of each approach?",
    "correctAnswer": "A senior developer would drop down to AREL or raw SQL when Active Record's standard query interface isn't expressive enough to generate the desired, complex SQL query, or when optimizing for specific database features.\n\n**AREL (Active Record Relation):**\n-   **When to use:** For complex `JOIN` conditions, intricate `CASE` statements, window functions, subqueries that return values, or when building dynamic queries programmatically where raw SQL injection is a concern.\n-   **Benefits:** Still provides some level of abstraction and database independence. Allows programmatic construction of SQL fragments, reducing risk of SQL injection compared to raw SQL. Keeps logic within Ruby.\n-   **Risks:** Higher learning curve. Can make code less readable for developers unfamiliar with AREL syntax.\n\n**Raw SQL:**\n-   **When to use:** For highly specialized, database-specific optimizations, using features not supported by Active Record/AREL, complex report generation, or when integrating with legacy systems where exact SQL is needed.\n-   **Benefits:** Complete control over the generated SQL. Can achieve maximum performance for specific scenarios. Leverages full power of the underlying RDBMS.\n-   **Risks:** Database-dependent (not portable). High risk of SQL injection if not properly sanitized (`sanitize_sql_array`). Harder to maintain and test. Bypasses Active Record's change tracking and callbacks.",
    "codeExample": "# Example using AREL for a complex JOIN condition\nposts_table = Post.arel_table\ncomments_table = Comment.arel_table\n\ncomplex_join = posts_table.join(comments_table).on(\n  posts_table[:id].eq(comments_table[:post_id])\n  .and(comments_table[:created_at].gt(1.year.ago))\n)\n\nPost.joins(complex_join.join_sources)\n\n# Example using Raw SQL (with sanitization!)\nsearch_term = 'ruby'\nPost.find_by_sql([\"SELECT * FROM posts WHERE title ILIKE ? OR body ILIKE ?\", \"%#{search_term}%\", \"%#{search_term}%\"])"
  },
  {
    "id": 11,
    "category": "Active Record / Associations",
    "level": "senior",
    "title": "Polymorphic Associations",
    "question": "Describe what a polymorphic association is in Active Record, when you would typically use one, and its main advantages and disadvantages compared to standard associations.",
    "correctAnswer": "A polymorphic association allows a model to belong to *more than one* other model, on a single association. For example, a `Comment` could belong to a `Post` or a `Photo`.\n\n**When to use:** When you have a common model (e.g., `Comment`, `Tag`, `Attachment`, `ActivityFeedItem`) that needs to be associated with several different types of models, without creating separate foreign keys and `belongs_to` definitions for each parent type.\n\n**Advantages:**\n-   **DRY (Don't Repeat Yourself):** Avoids duplicating columns and association definitions.\n-   **Flexibility:** Easily add new parent types without schema changes to the child model.\n-   **Scalability:** Good for generic features like comments, tags, or activity logging.\n\n**Disadvantages:**\n-   **Referential Integrity:** Databases don't directly enforce foreign key constraints for polymorphic associations, as `commentable_id` could refer to different tables. This means integrity must be handled at the application level.\n-   **Querying Complexity:** Can make some SQL queries more complex (e.g., finding all comments associated with *either* posts or photos requires `OR` clauses or multiple queries).\n-   **N+1 Problem with `includes`:** `includes` on a polymorphic association often results in multiple queries rather than a single join, as the associated tables are different types.",
    "codeExample": "# app/models/comment.rb\nclass Comment < ApplicationRecord\n  belongs_to :commentable, polymorphic: true\nend\n\n# app/models/post.rb\nclass Post < ApplicationRecord\n  has_many :comments, as: :commentable\nend\n\n# app/models/photo.rb\nclass Photo < ApplicationRecord\n  has_many :comments, as: :commentable\nend\n\n# Database Schema for comments table:\n# id: integer\n# content: text\n# commentable_id: integer\n# commentable_type: string (stores 'Post' or 'Photo')"
  },
  {
    "id": 12,
    "category": "Active Record / Data Integrity",
    "level": "senior",
    "title": "Database Constraints vs Active Record Validations",
    "question": "Discuss the trade-offs between enforcing data integrity using Active Record validations versus enforcing it at the database level (e.g., `NOT NULL`, `UNIQUE` constraints, foreign keys). When should you choose one over the other, or combine them?",
    "correctAnswer": "Active Record validations are application-level checks, while database constraints are enforced by the database itself.\n\n**Active Record Validations:**\n-   **Pros:** User-friendly error messages, flexibility (can be conditional), easily integrated with form rendering. Provide feedback *before* hitting the database.\n-   **Cons:** Can be bypassed (e.g., using `save(validate: false)`, direct SQL), not enforced for data inserted outside of Rails (e.g., raw SQL, other apps). Performance overhead for complex validations.\n\n**Database Constraints:**\n-   **Pros:** Guarantees data integrity at the lowest level, regardless of how data is inserted. Faster for simple checks (like `NOT NULL`, `UNIQUE`). Prevents corrupt data.\n-   **Cons:** Generic error messages (e.g., 'Duplicate entry for key'), harder to customize feedback for users. Less flexible (e.g., conditional unique checks are difficult).\n\n**When to use/combine:**\n-   **Combine them:** This is often the best practice. Use database constraints for fundamental integrity rules (`NOT NULL`, `UNIQUE`, foreign keys) that *must never* be violated. Use Active Record validations for user experience, complex business rules, and conditional checks.\n-   **Database-only for critical invariants:** If data integrity is paramount and cannot be bypassed under any circumstances (e.g., `unique: true` for email addresses, foreign key to prevent orphaned records).\n-   **AR-only for transient/complex logic:** For validations that depend on application state, external services, or complex business rules that don't map well to simple SQL constraints.",
    "codeExample": "# Model Validation (app/models/user.rb)\nclass User < ApplicationRecord\n  validates :email, presence: true, uniqueness: true\n  validates :password, length: { minimum: 8 }, on: :create # Conditional validation\nend\n\n# Database Migration (db/migrate/timestamp_add_email_to_users.rb)\nclass AddEmailToUsers < ActiveRecord::Migration[7.0]\n  def change\n    add_column :users, :email, :string, null: false\n    add_index :users, :email, unique: true\n    # Add a foreign key to enforce association integrity\n    # add_reference :posts, :user, foreign_key: true\n  end\nend"
  },
  {
    "id": 13,
    "category": "Active Record / Querying",
    "level": "senior",
    "title": "Understanding Scopes and Merge",
    "question": "You have a `Product` model with several scopes: `active`, `expensive` (price > 100), and `with_reviews`. How does chaining these scopes work in Active Record, and what does the `merge` method allow you to do with scopes?",
    "correctAnswer": "Chaining scopes in Active Record applies them sequentially, building up a more complex query. Each scope returns an `ActiveRecord::Relation` object, allowing further methods (including other scopes) to be called on it. This creates a powerful, readable, and reusable way to build queries.\n\nThe `merge` method allows you to combine the conditions, joins, orders, etc., of one `ActiveRecord::Relation` (or scope) into another. This is particularly useful when you want to dynamically apply a scope defined elsewhere, or combine scopes from different, but compatible, contexts. `merge` intelligently combines `WHERE`, `ORDER`, `LIMIT`, `OFFSET`, `FROM`, `GROUP`, and `HAVING` clauses, often using `AND` logic for `WHERE` clauses.",
    "codeExample": "class Product < ApplicationRecord\n  scope :active, -> { where(status: :active) }\n  scope :expensive, -> { where('price_in_cents > ?', 100_00) }\n  scope :with_reviews, -> { joins(:reviews).distinct }\n\n  # A separate scope for special products\n  scope :premium, -> { active.expensive }\nend\n\n# Chaining scopes:\n# Finds active products that are expensive and have reviews\nProduct.active.expensive.with_reviews \n# SQL: SELECT DISTINCT \"products\".* FROM \"products\" INNER JOIN \"reviews\" ON \"reviews\".\"product_id\" = \"products\".\"id\" WHERE \"products\".\"status\" = 0 AND (price_in_cents > 10000)\n\n# Using `merge`:\n# Imagine you have a base scope for a dashboard\nbase_products = Product.active\n\n# Later, you want to add the 'expensive' criteria\nfinal_products = base_products.merge(Product.expensive)\n# This is equivalent to Product.active.expensive"
  },
  {
    "id": 14,
    "category": "Active Record / Performance",
    "level": "senior",
    "title": "Counter Caching",
    "question": "Explain what counter caching is and why it's a valuable performance optimization in Rails. Provide an example of how you'd set it up for a `Post` model with many `Comments`.",
    "correctAnswer": "Counter caching is a performance optimization where the count of associated records is stored directly as a column in the parent model's table. Instead of performing a `COUNT(*)` query every time you need the number of associated records, the count is simply read from a column. Rails automatically increments/decrements this counter when associated records are created or destroyed.\n\n**Why it's valuable:**\n-   **Reduces Database Queries:** Eliminates N+1 `COUNT` queries, especially common in lists or dashboards.\n-   **Faster Reads:** Reading an integer column is much faster than executing an aggregate SQL query.\n-   **Simplicity:** Rails handles the updating automatically, requiring minimal code.\n\n**Setup Example:**\n1.  **Migration:** Add a `comments_count` integer column (with a default of 0) to the `posts` table.\n2.  **Model Association:** Add `counter_cache: true` to the `belongs_to` association in the child model (`Comment`).",
    "codeExample": "# 1. Migration to add the counter cache column:\nclass AddCommentsCountToPosts < ActiveRecord::Migration[7.0]\n  def change\n    add_column :posts, :comments_count, :integer, default: 0\n  end\nend\n\n# 2. Update the Comment model (child) to enable caching:\n# app/models/comment.rb\nclass Comment < ApplicationRecord\n  belongs_to :post, counter_cache: true\nend\n\n# 3. Update the Post model (parent) - no changes needed, but often seen:\n# app/models/post.rb\nclass Post < ApplicationRecord\n  has_many :comments\nend\n\n# Usage:\npost = Post.first\nputs post.comments_count # Reads directly from the column, no query"
  },
  {
    "id": 15,
    "category": "Active Record / Concurrency",
    "level": "senior",
    "title": "Optimistic vs. Pessimistic Locking",
    "question": "Compare and contrast optimistic and pessimistic locking in the context of Active Record. When would you use each, and what are their mechanisms for preventing race conditions during concurrent updates?",
    "correctAnswer": "**Optimistic Locking:**\n-   **Mechanism:** Adds a `lock_version` integer column to the database table. When a record is updated, Active Record increments this version number. If another update attempt is made on an outdated version of the record (i.e., its `lock_version` in the database doesn't match the one the object was loaded with), it raises an `ActiveRecord::StaleObjectError`.\n-   **When to use:** Preferred for situations where conflicts are rare and user experience tolerates occasional re-submission (e.g., editing a blog post, where two users might coincidentally edit at the same time). It's 'optimistic' that conflicts won't occur.\n-   **Pros:** Minimal database overhead, doesn't block other users.\n-   **Cons:** Requires users to re-submit changes if a conflict occurs. Needs client-side handling of the `StaleObjectError`.\n\n**Pessimistic Locking:**\n-   **Mechanism:** Uses database-level locks (e.g., `SELECT ... FOR UPDATE` in PostgreSQL/MySQL). When a record is loaded for an update, the database places a lock on that record (or row), preventing other transactions from modifying it until the current transaction commits or rolls back.\n-   **When to use:** For critical operations where data integrity and preventing simultaneous updates is paramount, and performance impact of blocking is acceptable (e.g., deducting money from an account, managing inventory levels where an exact count is crucial). It's 'pessimistic' about conflicts.\n-   **Pros:** Guarantees no conflicts at the database level. Simpler client-side logic as no re-submission is needed.\n-   **Cons:** Can lead to deadlocks if not used carefully. Can reduce concurrency and impact performance by blocking other transactions.\n\n**Summary:** Optimistic is generally preferred for its lighter overhead and better concurrency if stale data can be handled by the application. Pessimistic is for high-integrity, low-tolerance-for-error scenarios where blocking is acceptable.",
    "codeExample": "# Optimistic Locking:\n# 1. Add lock_version column: rails g migration AddLockVersionToProducts lock_version:integer\n# 2. In Product model: validates :lock_version, presence: true (optional, but good practice)\n\nproduct1 = Product.find(1) # lock_version: 1\nproduct2 = Product.find(1) # lock_version: 1\n\nproduct1.update(price: 10)\n# Database now has product 1 with lock_version: 2\n\n# This will raise ActiveRecord::StaleObjectError because product2's lock_version (1) \n# doesn't match the database's current lock_version (2)\nbegin\n  product2.update(name: 'Updated Name')\nrescue ActiveRecord::StaleObjectError\n  puts 'Conflict detected! Please try again.'\nend\n\n# Pessimistic Locking:\nProduct.transaction do\n  product = Product.lock.find(1)\n  # The database row for product 1 is now locked\n  product.update(inventory: product.inventory - 1)\n  # Lock released when transaction commits or rolls back\nend"
  },
  {
    "id": 16,
    "category": "Active Record / Advanced Features",
    "level": "senior",
    "title": "When to skip Active Record and use raw SQL",
    "question": "Beyond simple queries, describe a scenario where a senior developer might decide to bypass Active Record entirely and execute raw SQL directly through `connection.execute` or `connection.select_all`. What are the primary reasons and considerations for such a decision?",
    "correctAnswer": "A senior developer might bypass Active Record entirely and use raw SQL when:\n\n1.  **Complex Reporting & Aggregations:** For highly optimized, custom reports involving intricate `GROUP BY`, `HAVING`, window functions, or complex joins across many tables that are difficult or inefficient to construct with Active Record/AREL.\n2.  **Performance Critical Operations:** When micro-optimizing specific database operations that Active Record's overhead might hinder, or when needing to leverage very specific database engine features (e.g., PostgreSQL's `jsonb` functions, specific indexing strategies, `MATERIALIZED VIEWS`).\n3.  **Bulk Operations:** For extremely large-scale data imports, updates, or deletions where loading Active Record objects into memory would be prohibitive (e.g., `INSERT ... SELECT`, `UPDATE ... FROM`).\n4.  **Database-Specific Features:** Accessing features not abstracted by Active Record, such as specific stored procedures, triggers, or advanced data types.\n5.  **Legacy Database Integration:** Interacting with a database schema that doesn't conform to Active Record's conventions, where direct SQL offers more control.\n\n**Primary Reasons & Considerations:**\n-   **Control:** Absolute control over the SQL generated.\n-   **Performance:** Potentially faster for highly optimized queries.\n-   **Flexibility:** Access to full RDBMS capabilities.\n-   **Lack of Active Record Objects:** `connection.select_all` returns an `ActiveRecord::Result` object (an array of hashes), not `ActiveRecord::Base` instances. This means no callbacks, no dirty tracking, no validations, no associations.\n-   **SQL Injection Risk:** Higher risk of SQL injection if inputs are not meticulously sanitized (`ActiveRecord::Base.sanitize_sql_array`).\n-   **Portability:** Raw SQL can be database-specific, reducing application portability.\n-   **Maintainability:** Harder to read and maintain, as it breaks the Active Record abstraction.",
    "codeExample": "# Scenario: Generating a complex weekly sales report with custom aggregations\n# that might involve combining data from multiple tables in a specific way,\n# perhaps using window functions, and for which Active Record would generate\n# less efficient or more convoluted queries.\n\n# Using connection.execute for a complex report:\nresults = ActiveRecord::Base.connection.execute(\n  <<-SQL\n    SELECT\n      users.name,\n      DATE_TRUNC('week', orders.created_at) AS week,\n      SUM(order_items.price * order_items.quantity) AS total_sales,\n      COUNT(DISTINCT orders.id) AS order_count\n    FROM users\n    JOIN orders ON orders.user_id = users.id\n    JOIN order_items ON order_items.order_id = orders.id\n    WHERE orders.created_at >= '2024-01-01'\n    GROUP BY users.id, week\n    ORDER BY total_sales DESC\n  SQL\n)\n\n# Process results (returns array of hashes)\nresults.each do |row|\n  puts \"#{row['name']}: $#{row['total_sales']} (#{row['order_count']} orders)\"\nend"
  },
  {
    "id": 17,
    "category": "Active Record / Performance & Advanced Querying",
    "level": "senior",
    "title": "Optimizing Complex Data Retrieval with Eager Loading and SQL",
    "question": "Imagine you are working on a social media platform. You have three models: `User`, `Post`, and `Comment`. A `User` `has_many :posts` and `has_many :comments`. A `Post` `belongs_to :user` and `has_many :comments`. A `Comment` `belongs_to :user` and `belongs_to :post`.\n\nYour task is to display a dashboard showing a list of the 10 most recent posts. For each post, you need to display:\n  - The post's title and content.\n  - The author's username.\n  - The count of comments on that post.\n  - The usernames of the first 3 recent commenters on that post.\n\nWrite the Active Record query (or queries) to efficiently retrieve all necessary data for this dashboard. Focus on avoiding N+1 queries and optimizing performance.",
    "correctAnswer": "The solution involves a combination of `includes` with custom `LIMIT` and `ORDER` clauses on associations, or potentially using `LEFT JOIN` and subqueries for the most complex parts. The key is to minimize separate database hits.\n\n```ruby\nPost.includes(:user) # Eager load post authors\n    .left_joins(:comments) # Join comments to count them\n    .select(\n      'posts.*',\n      'users.username AS author_username',\n      'COUNT(comments.id) AS comments_count' # Aggregate count\n    )\n    .group('posts.id', 'users.username') # Group for COUNT\n    .order(created_at: :desc)\n    .limit(10)\n    .eager_load(recent_comments: :user) # Eager load recent comments and their authors\n```\n\n**Explanation of `eager_load` for recent comments (the trickiest part):**\nThe `eager_load` (or `includes` with a lambda) for `recent_comments` would require a custom association and scope. We'd define a `has_many :recent_comments` association on the `Post` model that limits and orders comments. `eager_load` on this specific association (or `includes` if Rails can optimize) is crucial. The `SELECT` clause with `COUNT` would handle the total comment count efficiently.\n\n**Post Model (needed for the above query):**\n```ruby\nclass Post < ApplicationRecord\n  belongs_to :user\n  has_many :comments\n  has_many :recent_comments, -> { order(created_at: :desc).limit(3) }, class_name: 'Comment'\nend\n```\n\n**SQL Generated (simplified):**\n```sql\nSELECT\n  posts.*,\n  users.username AS author_username,\n  COUNT(comments.id) AS comments_count\nFROM posts\nINNER JOIN users ON users.id = posts.user_id\nLEFT OUTER JOIN comments ON comments.post_id = posts.id\nGROUP BY posts.id, users.username\nORDER BY posts.created_at DESC\nLIMIT 10;\n\n-- Separate query for eager-loading recent comments (simplified, Rails handles the WHERE IN)\nSELECT comments.*, users.username AS commenter_username FROM comments\nINNER JOIN users ON users.id = comments.user_id\nWHERE comments.post_id IN (1, 2, ..., 10) -- IDs of the 10 posts from first query\nORDER BY comments.created_at DESC\nLIMIT 3; -- LIMIT 3 PER POST is complex to do in a single query without window functions\n```\n\n**Note on `LIMIT 3` for comments:** Retrieving the 'first 3 recent commenters' *per post* in a single, highly optimized query with standard `includes` or `eager_load` is challenging for Rails without leveraging database-specific window functions (e.g., `ROW_NUMBER() OVER (PARTITION BY post_id ORDER BY created_at DESC)`). A common Rails pattern for this is to use a `has_many` association with a `limit` and `order` scope, and then allow `includes` or `eager_load` to handle it, which will likely result in a separate query for the comments, but it will be a single query for all posts' comments (e.g., `WHERE post_id IN (...)`). A truly single-query approach would involve AREL and `LATERAL JOIN` or window functions for PostgreSQL/MySQL.\n\nFor a senior dev, recognizing the complexity of 'limit N per group' and suggesting a performant compromise (like a second query for comments) or proposing database-specific solutions is key.",
    "codeExample": "class User < ApplicationRecord\n  has_many :posts\n  has_many :comments\nend\n\nclass Post < ApplicationRecord\n  belongs_to :user\n  has_many :comments\n  # Custom association for eager-loading limited comments\n  has_many :recent_comments, -> { order(created_at: :desc).limit(3) }, class_name: 'Comment'\nend\n\nclass Comment < ApplicationRecord\n  belongs_to :user\n  belongs_to :post\nend\n\n# The final query solution\ndashboard_posts = Post.includes(:user) # Eager load post authors\n                       .left_joins(:comments) # Join comments to count them\n                       .select(\n                         'posts.*',\n                         'users.username AS author_username',\n                         'COUNT(comments.id) AS comments_count'\n                       )\n                       .group('posts.id', 'users.username')\n                       .order(created_at: :desc)\n                       .limit(10)\n                       .eager_load(recent_comments: :user) # Eager load recent comments and their authors\n\n# Displaying the data\ndashboard_posts.each do |post|\n  puts \"Title: #{post.title}\"\n  puts \"Content: #{post.content.truncate(100)}\"\n  puts \"Author: #{post.user.username}\" # .user is eager loaded\n  puts \"Comments Count: #{post.comments_count}\" # From COUNT aggregate\n  puts \"Recent Commenters:\"\n  post.recent_comments.each do |comment|\n    puts \"  - #{comment.user.username}: #{comment.content.truncate(50)}\" # .user on comment is eager loaded\n  end\n  puts \"---\"\nend",
    "hasSubQuestions": true,
    "subQuestions": [
      {
        "id": 1701,
        "question": "Initially, if you just did `Post.all.limit(10)`, and then in your view iterated through `@posts.each { |post| puts post.user.username; puts post.comments.count }`, what performance problem would arise and why?",
        "correctAnswer": "This scenario would immediately lead to an **N+1 query problem**.\n-   **N+1 for Authors:** `Post.all.limit(10)` would perform 1 query to fetch 10 posts.\n-   Then, for each of the 10 posts, `post.user.username` would trigger a separate `SELECT` query to fetch the associated `User` (10 queries). So, 1 (posts) + 10 (users) = 11 queries.\n-   **N+1 for Comment Counts:** Similarly, `post.comments.count` would trigger another separate `SELECT COUNT(*)` query for each of the 10 posts (another 10 queries). So, 11 + 10 = 21 queries in total.\nThis leads to significantly degraded performance as the number of posts grows.",
        "codeExample": "# app/controllers/posts_controller.rb\nclass PostsController < ApplicationController\n  def dashboard\n    @posts = Post.all.limit(10) # 1 query\n  end\nend\n\n# app/views/posts/dashboard.html.erb\n<% @posts.each do |post| %>\n  <p>Title: <%= post.title %></p>\n  <p>Author: <%= post.user.username %></p>  \n  <p>Comments: <%= post.comments.count %></p> \n<% end %>"
      },
      {
        "id": 1702,
        "question": "How would you modify the query to efficiently fetch the post's author and the total comment count for each of the 10 posts, avoiding N+1 queries for these specific pieces of data?",
        "correctAnswer": "To fetch the author and comment count efficiently, you'd use `includes` for the user and `left_joins` with `select` and `group` for the comment count:\n\n```ruby\nPost.includes(:user) # Eager load the author\n    .left_joins(:comments) # Join comments to perform aggregate count\n    .select(\n      'posts.*',\n      'users.username AS author_username',\n      'COUNT(comments.id) AS comments_count' # Aggregate the count\n    )\n    .group('posts.id', 'users.username') # Group by posts.id and users.username for the COUNT\n    .order(created_at: :desc)\n    .limit(10)\n```\n\n**Explanation:**\n-   `includes(:user)`: Eager loads the `User` association, preventing N+1 for `post.user`.\n-   `left_joins(:comments)`: Uses a `LEFT OUTER JOIN` to include comments. `LEFT` is important so posts without comments are still returned.\n-   `select('posts.*', 'users.username AS author_username', 'COUNT(comments.id) AS comments_count')`: Selects all post columns, the user's username (aliased for clarity), and the aggregated count of comments.\n-   `group('posts.id', 'users.username')`: Necessary because of the `COUNT` aggregate function. All selected columns that are *not* aggregates must be in the `GROUP BY` clause.",
        "codeExample": "class Post < ApplicationRecord\n  belongs_to :user\n  has_many :comments\nend\n\n# The modified query:\ndashboard_posts = Post.includes(:user)\n                       .left_joins(:comments)\n                       .select(\n                         'posts.*',\n                         'users.username AS author_username',\n                         'COUNT(comments.id) AS comments_count'\n                       )\n                       .group('posts.id', 'users.username')\n                       .order(created_at: :desc)\n                       .limit(10)\n\n# Usage:\ndashboard_posts.each do |post|\n  puts \"Title: #{post.title}\"\n  puts \"Author: #{post.user.username}\" # No N+1\n  puts \"Comments: #{post.comments_count}\" # No N+1\nend"
      },
      {
        "id": 1703,
        "question": "The most challenging part is fetching the usernames of the first 3 recent commenters *for each post*. How would you extend your query or strategy to efficiently achieve this, discussing any limitations of standard Active Record for this specific requirement?",
        "correctAnswer": "Fetching a 'limit N per group' (e.g., 3 comments *per post*) is notoriously difficult to do in a single, simple Active Record query without leveraging database-specific features. Standard `includes` or `eager_load` would fetch *all* comments for the 10 posts and then apply the limit in Ruby, or simply apply the limit to the overall comment set, not per post. \n\n**Strategy (Best Active Record Idiom):**\n1.  **Define a Custom `has_many` Association with Scope:** Create a new association on `Post` that includes the `order` and `limit` for comments. \n2.  **Eager Load this Custom Association:** Use `eager_load` or `includes` with this new association and its associated `user`.\n\n```ruby\n# In Post model:\nclass Post < ApplicationRecord\n  # ... existing associations ...\n  has_many :recent_comments, -> { order(created_at: :desc).limit(3) }, class_name: 'Comment'\nend\n\n# Modified query:\ndashboard_posts = Post.includes(:user)\n                       .left_joins(:comments)\n                       .select(\n                         'posts.*',\n                         'users.username AS author_username',\n                         'COUNT(comments.id) AS comments_count'\n                       )\n                       .group('posts.id', 'users.username')\n                       .order(created_at: :desc)\n                       .limit(10)\n                       .eager_load(recent_comments: :user) # Eager load the limited comments and their authors\n```\n\n**Limitations of Standard Active Record:**\n-   A single `LEFT JOIN` for `comments` combined with `GROUP BY` and `LIMIT` is problematic for 'limit N per group'. The `LIMIT` would apply to the overall joined result set, not individually per post group.\n-   `includes` or `eager_load` on a standard `has_many` would load *all* comments, then the Ruby code would pick the top 3, defeating the purpose for large comment counts.\n\n**Advanced Database-Specific Solutions (if Active Record is insufficient):**\nFor truly optimal performance in a single query, one would typically use:\n-   **PostgreSQL:** `LATERAL JOIN` or window functions (`ROW_NUMBER() OVER (PARTITION BY post_id ORDER BY created_at DESC)`) combined with a subquery.\n-   **MySQL:** Subqueries or `LEFT JOIN` with tricks (e.g., `GROUP_CONCAT` for usernames, or using variables for row numbering in older MySQL versions).\n\nA senior developer should be aware of these database-specific solutions and when to consider dropping to AREL or raw SQL for such complex requirements if Active Record's built-in tools prove too inefficient.",
        "codeExample": "class Post < ApplicationRecord\n  # ... existing code ...\n  has_many :recent_comments, -> { order(created_at: :desc).limit(3) }, class_name: 'Comment'\nend\n\n# The full query (as in the main answer)\ndashboard_posts = Post.includes(:user)\n                       .left_joins(:comments)\n                       .select(\n                         'posts.*',\n                         'users.username AS author_username',\n                         'COUNT(comments.id) AS comments_count'\n                       )\n                       .group('posts.id', 'users.username')\n                       .order(created_at: :desc)\n                       .limit(10)\n                       .eager_load(recent_comments: :user)\n\n# In view or service:\n# post.recent_comments.each do |comment|\n#   puts comment.user.username # .user is eager loaded thanks to eager_load(recent_comments: :user)\n# end"
      }
    ]
  },
  {
    "id": 18,
    "category": "Security / Junior",
    "level": "junior",
    "title": "SQL Injection Basics",
    "question": "What is SQL Injection, and how does Rails' Active Record help prevent it when you use methods like `where` with question mark placeholders?",
    "correctAnswer": "SQL Injection is a code injection technique where malicious SQL commands are inserted into an input field to tamper with or gain unauthorized access to a database. Rails' Active Record helps prevent this by using parameterized queries when you use question mark placeholders (`?`) in methods like `where`. Instead of directly concatenating user input into the SQL string, Rails passes the input as a separate parameter to the database driver, which ensures the input is treated as data, not executable code.",
    "codeExample": "# Vulnerable (DO NOT DO THIS!):\n# User input directly concatenated\n# name = params[:user_name]\n# User.where(\"name = '#{name}'\") \n# If name = \"' OR 1=1 --\", the query becomes: SELECT * FROM users WHERE name = '' OR 1=1 --'\n\n# Secure (Rails sanitizes input):\n# User input passed as a parameter\nname = params[:user_name]\nUser.where(\"name = ?\", name) \n# Becomes: SELECT * FROM users WHERE name = $1 -- parameter ' OR 1=1 --' is treated as a string value"
  },
  {
    "id": 19,
    "category": "Security / Junior",
    "level": "junior",
    "title": "Cross-Site Request Forgery (CSRF)",
    "question": "What is Cross-Site Request Forgery (CSRF)? How does Rails protect against it by default?",
    "correctAnswer": "CSRF is an attack where an attacker tricks a user's browser into making an unwanted request to a web application in which they're currently authenticated. For example, tricking an logged-in user to click a link that sends a POST request to transfer money from their bank.\n\nRails protects against CSRF by default using an **authenticity token** (or CSRF token). This token is a random string embedded in forms and AJAX requests. When a request comes in, Rails verifies that the token submitted with the request matches the token stored in the user's session. If they don't match, Rails rejects the request, preventing an attacker from forging requests from external sites.",
    "codeExample": "# In a Rails view, Rails automatically adds this hidden field to forms:\n# <form action=\"/posts\" method=\"post\">\n#   <input type=\"hidden\" name=\"authenticity_token\" value=\"<random_string_here>\">\n#   ...\n# </form>\n\n# In app/controllers/application_controller.rb (default for Rails apps):\nclass ApplicationController < ActionController::Base\n  protect_from_forgery with: :exception # This line enables CSRF protection\nend"
  },
  {
    "id": 20,
    "category": "Security / Mid",
    "level": "mid",
    "title": "Strong Parameters",
    "question": "What problem does 'Strong Parameters' solve in Rails, and how does it prevent mass assignment vulnerabilities? Provide an example.",
    "correctAnswer": "Strong Parameters solves the **mass assignment vulnerability**. This vulnerability occurs when an attacker can submit arbitrary input fields (e.g., `is_admin: true`) via a form, and if the application directly assigns all `params` to a model, the attacker could change attributes they shouldn't have access to.\n\nStrong Parameters forces you to explicitly **whitelist** which attributes are allowed to be assigned to a model from `params`. By defining a permitted list, any unpermitted attributes are silently discarded, preventing malicious assignments.",
    "codeExample": "# In a controller:\nclass UsersController < ApplicationController\n  def create\n    # DANGEROUS: User.new(params[:user]) might allow assigning 'is_admin' or 'admin_level'\n    # if an attacker adds those to the form/request payload.\n\n    # SECURE: Using Strong Parameters\n    @user = User.new(user_params)\n    if @user.save\n      redirect_to @user\n    else\n      render :new\n    end\n  end\n\n  private\n\n  def user_params\n    # ONLY :name, :email, and :password are allowed for mass assignment\n    params.require(:user).permit(:name, :email, :password)\n  end\nend\n\n# If params[:user] contains { name: \"Alice\", email: \"a@b.com\", password: \"123\", is_admin: true }\n# Only name, email, and password will be assigned to the new User object. is_admin will be ignored."
  },
  {
    "id": 21,
    "category": "Security / Mid",
    "level": "mid",
    "title": "Cross-Site Scripting (XSS)",
    "question": "What is Cross-Site Scripting (XSS)? How does Rails, particularly in its view layer (ERB), help to mitigate XSS vulnerabilities by default? What is a scenario where you might still be vulnerable?",
    "correctAnswer": "Cross-Site Scripting (XSS) is a type of security vulnerability that enables attackers to inject client-side scripts (e.g., JavaScript) into web pages viewed by other users. These scripts can then bypass access controls and perform actions like stealing session cookies, defacing websites, or redirecting users.\n\nRails mitigates XSS by default through **auto-escaping** in its ERB templates. Any output from `<%= ... %>` is automatically HTML-escaped, converting characters like `<`, `>`, `&`, and `\"` into their HTML entities (`&lt;`, `&gt;`, `&amp;`, `&quot;`). This prevents injected script tags from being interpreted as code by the browser.\n\n**Scenario where you might still be vulnerable:**\n-   **Using `html_safe` or `raw`:** If you explicitly use `html_safe` or `raw` on user-provided input without properly sanitizing it first. This tells Rails 'I know this content is safe, don't escape it,' which can be dangerous.\n-   **Custom JavaScript injection:** If dynamic JavaScript is constructed using unsanitized user input.\n-   **External Libraries/Gems:** If a third-party library or gem introduces its own rendering that doesn't properly escape output.\n-   **Stored XSS in attributes:** If user input is directly inserted into HTML attributes without proper attribute-specific escaping (though Rails does a good job with most helpers).",
    "codeExample": "# In a Rails view (e.g., app/views/posts/show.html.erb)\n\n# User-provided content:\n# @post.title = \"My <script>alert('XSS!');</script> Post\"\n\n# Default Rails behavior (SECURE):\n# <%= @post.title %> \n# Output: My &lt;script&gt;alert(&#39;XSS!&#39;);&lt;/script&gt; Post\n# The script is rendered as text, not executed.\n\n# DANGEROUS (DO NOT DO THIS with untrusted input):\n# <%= @post.title.html_safe %>\n# Output: My <script>alert('XSS!');</script> Post\n# The script would be executed by the browser."
  },
  {
    "id": 22,
    "category": "Active Record / Polymorphic Associations / File Uploads",
    "level": "mid",
    "title": "User Profile with Polymorphic Media Library",
    "question": "You are building a social profile feature. A `User` has a `Profile`, and both `User` and `Profile` can have various media (images, videos) associated with them. Specifically:\n  - A `User` can have a `profile_picture` (Image) and a `video_presentation` (Video).\n  - A `Profile` can have a `background_image` (Image).\n  - A `Profile` also stores `bio` and `social_links` (as a JSONB hash).\n\nDesign the models, associations (including polymorphic for media), and controller logic to handle the creation and updating of a user's profile and its associated media. Assume you are using Active Storage for file uploads.\n\nProvide the migrations, model definitions, and a conceptual controller action for updating a user's profile and media.",
    "correctAnswer": "This exercise requires setting up `has_one_attached` for Active Storage, defining a polymorphic `MediaItem` model (or similar) if you want a dedicated model, or directly using `has_one_attached` with custom association names. For a mid-level, using `has_one_attached` directly with appropriate names is often the most Rails-idiomatic approach for simple attachments. For more complex metadata on media, a dedicated `MediaItem` model with a `has_one_attached` *inside it* would be considered more advanced.\n\nGiven the requirements, `ActiveStorage`'s `has_one_attached` with direct associations is the most straightforward and idiomatic Rails solution for a mid-level, handling polymorphic-like behavior by having distinct `has_one_attached` declarations on each model.\n\n**Key Steps & Components:**\n\n1.  **Migrations:** Create `users` and `profiles` tables. For `profiles`, add `bio` and `social_links` (JSONB).\n2.  **Active Storage Setup:** Ensure `active_storage:install` has been run.\n3.  **Model Definitions:**\n    * `User`: `has_one :profile`, `has_one_attached :profile_picture`, `has_one_attached :video_presentation`.\n    * `Profile`: `belongs_to :user`, `has_one_attached :background_image`, `store_accessor` for `social_links`.\n4.  **Controller Action (conceptual):** Handle nested parameters for `profile` and separate file uploads for `user` and `profile` attachments.",
    "codeExample": "```ruby\n# --- 1. Migrations --- (Run 'rails db:migrate' after generation)\n\n# db/migrate/[timestamp]_create_users.rb\nclass CreateUsers < ActiveRecord::Migration[7.0]\n  def change\n    create_table :users do |t|\n      t.string :email, null: false, index: { unique: true }\n      t.string :username, null: false, index: { unique: true }\n      t.timestamps\n    end\n  end\nend\n\n# db/migrate/[timestamp]_create_profiles.rb\nclass CreateProfiles < ActiveRecord::Migration[7.0]\n  def change\n    create_table :profiles do |t|\n      t.references :user, null: false, foreign_key: true\n      t.text :bio\n      t.jsonb :social_links, default: {}\n      t.timestamps\n    end\n    add_index :profiles, :social_links, using: :gin # For querying JSONB\n  end\nend\n\n# --- 2. Model Definitions --- (app/models/...)\n\n# app/models/user.rb\nclass User < ApplicationRecord\n  has_one :profile, dependent: :destroy\n\n  # Active Storage attachments for User\n  has_one_attached :profile_picture # Image\n  has_one_attached :video_presentation # Video\n\n  validates :username, presence: true, uniqueness: true\n  validates :email, presence: true, uniqueness: true, format: { with: URI::MailTo::EMAIL_REGEXP }\n\n  after_create :create_default_profile\n\n  private\n\n  def create_default_profile\n    create_profile!\n  end\nend\n\n# app/models/profile.rb\nclass Profile < ApplicationRecord\n  belongs_to :user\n\n  # Active Storage attachments for Profile\n  has_one_attached :background_image # Image\n\n  # For easy access to social_links JSONB hash keys\n  store_accessor :social_links, :twitter, :linkedin, :github\n\n  validates :bio, length: { maximum: 500 }\nend\n\n# --- 3. Conceptual Controller Action --- (app/controllers/users_controller.rb)\n\nclass UsersController < ApplicationController\n  before_action :authenticate_user! # Devise or similar for authentication\n  before_action :set_user, only: [:show, :edit, :update]\n\n  def show\n    # @user and @profile will be available\n  end\n\n  def edit\n    @profile = @user.profile # Ensure profile is loaded for form\n  end\n\n  def update\n    # Handle user attributes and profile attributes (nested)\n    # Handle attachment updates separately as Active Storage attaches directly to the model\n    if @user.update(user_params)\n      redirect_to @user, notice: 'Profile was successfully updated.'\n    else\n      @profile = @user.profile # Re-load for form rendering on error\n      render :edit\n    end\n  end\n\n  private\n\n  def set_user\n    # In a real app, this would be current_user for editing their own profile\n    # For this exercise, assume it's loading a user for display/admin\n    @user = User.find(params[:id])\n  end\n\n  def user_params\n    params.require(:user).permit(\n      :username,\n      :profile_picture, # Direct Active Storage attachment\n      :video_presentation, # Direct Active Storage attachment\n      profile_attributes: [\n        :id, # Needed for nested form update\n        :bio,\n        :background_image, # Direct Active Storage attachment\n        social_links: [:twitter, :linkedin, :github] # Nested hash for JSONB\n      ]\n    )\n  end\nend\n\n# --- 4. Conceptual View Form --- (app/views/users/_form.html.erb)\n\n# Note: This is simplified. In a real app, you'd use `form_with model: @user` \n# and `fields_for :profile, @user.profile` for nested attributes.\n\n\n<%= form_with(model: @user, local: true) do |form| %>\n  <div class=\"field\">\n    <%= form.label :username %><br>\n    <%= form.text_field :username %>\n  </div>\n\n  <div class=\"field\">\n    <%= form.label :profile_picture %><br>\n    <%= form.file_field :profile_picture %>\n    <% if @user.profile_picture.attached? %>\n      <%= image_tag @user.profile_picture, size: '100x100' %>\n    <% end %>\n  </div>\n\n  <div class=\"field\">\n    <%= form.label :video_presentation %><br>\n    <%= form.file_field :video_presentation %>\n    <% if @user.video_presentation.attached? %>\n      <p>Video attached: <%= @user.video_presentation.filename %></p>\n    <% end %>\n  </div>\n\n  <%= form.fields_for :profile, @user.profile do |profile_form| %>\n    <div class=\"field\">\n      <%= profile_form.label :bio %><br>\n      <%= profile_form.text_area :bio %>\n    </div>\n\n    <div class=\"field\">\n      <%= profile_form.label :background_image %><br>\n      <%= profile_form.file_field :background_image %>\n      <% if @user.profile.background_image.attached? %>\n        <%= image_tag @user.profile.background_image, size: '200x200' %>\n      <% end %>\n    </div>\n\n    <h3>Social Links</h3>\n    <div class=\"field\">\n      <%= profile_form.label :twitter %><br>\n      <%= profile_form.text_field 'social_links[twitter]' %> \n    </div>\n    <div class=\"field\">\n      <%= profile_form.label :linkedin %><br>\n      <%= profile_form.text_field 'social_links[linkedin]' %>\n    </div>\n    <div class=\"field\">\n      <%= profile_form.label :github %><br>\n      <%= profile_form.text_field 'social_links[github]' %>\n    </div>\n  <% end %>\n\n  <div class=\"actions\">\n    <%= form.submit 'Update Profile' %>\n  </div>\n<% end %>\n```",
    "image": "/images/rails/polymorphic_associations.png",
    "hasSubQuestions": true,
    "subQuestions": [
      {
        "id": 3401,
        "question": "Provide the necessary database migrations for the `User` and `Profile` models, ensuring appropriate data types and indexing. Include the `social_links` field as a `JSONB` type.",
        "correctAnswer": "```ruby\n# db/migrate/[timestamp]_create_users.rb\nclass CreateUsers < ActiveRecord::Migration[7.0]\n  def change\n    create_table :users do |t|\n      t.string :email, null: false, index: { unique: true }\n      t.string :username, null: false, index: { unique: true }\n      t.timestamps\n    end\n  end\nend\n\n# db/migrate/[timestamp]_create_profiles.rb\nclass CreateProfiles < ActiveRecord::Migration[7.0]\n  def change\n    create_table :profiles do |t|\n      t.references :user, null: false, foreign_key: true, index: { unique: true }\n      t.text :bio\n      t.jsonb :social_links, default: {}\n      t.timestamps\n    end\n    add_index :profiles, :social_links, using: :gin # For efficient querying of JSONB fields\n  end\nend\n```",
        "codeExample": "class CreateUsers < ActiveRecord::Migration[7.0]\n  def change\n    create_table :users do |t|\n      t.string :email, null: false, index: { unique: true }\n      t.string :username, null: false, index: { unique: true }\n      t.timestamps\n    end\n  end\nend\n\nclass CreateProfiles < ActiveRecord::Migration[7.0]\n  def change\n    create_table :profiles do |t|\n      t.references :user, null: false, foreign_key: true, index: { unique: true }\n      t.text :bio\n      t.jsonb :social_links, default: {}\n      t.timestamps\n    end\n    add_index :profiles, :social_links, using: :gin # For querying JSONB\n  end\nend"
      },
      {
        "id": 3402,
        "question": "Define the `User` and `Profile` models, including their associations and the necessary Active Storage declarations for `profile_picture`, `video_presentation`, and `background_image`. How would you make `social_links` easily accessible as individual fields (e.g., `profile.twitter`)?",
        "correctAnswer": "```ruby\n# app/models/user.rb\nclass User < ApplicationRecord\n  has_one :profile, dependent: :destroy # If user is deleted, profile should be too\n\n  # Active Storage attachments for User\n  has_one_attached :profile_picture \n  has_one_attached :video_presentation\n\n  validates :username, presence: true, uniqueness: true\n  validates :email, presence: true, uniqueness: true, format: { with: URI::MailTo::EMAIL_REGEXP }\n\n  # Automatically create a profile when a user is created\n  after_create :create_default_profile\n\n  private\n\n  def create_default_profile\n    create_profile!\n  end\nend\n\n# app/models/profile.rb\nclass Profile < ApplicationRecord\n  belongs_to :user\n\n  # Active Storage attachments for Profile\n  has_one_attached :background_image\n\n  # Allows direct access to JSONB keys as if they were attributes\n  store_accessor :social_links, :twitter, :linkedin, :github\n\n  validates :bio, length: { maximum: 500 }, allow_blank: true\nend\n```\n\n**Explanation for `social_links`:** The `store_accessor :social_links, :twitter, :linkedin, :github` line in the `Profile` model (available in Active Record for `json` and `jsonb` columns) allows you to read and write directly to `profile.twitter`, `profile.linkedin`, etc., transparently interacting with the underlying `social_links` JSONB hash. This provides a clean interface without manual `profile.social_links['twitter']` calls.",
        "codeExample": "class User < ApplicationRecord\n  has_one :profile, dependent: :destroy\n\n  has_one_attached :profile_picture\n  has_one_attached :video_presentation\n\n  validates :username, presence: true, uniqueness: true\n  validates :email, presence: true, uniqueness: true, format: { with: URI::MailTo::EMAIL_REGEXP }\n\n  after_create :create_default_profile\n\n  private\n\n  def create_default_profile\n    create_profile!\n  end\nend\n\nclass Profile < ApplicationRecord\n  belongs_to :user\n\n  has_one_attached :background_image\n\n  store_accessor :social_links, :twitter, :linkedin, :github\n\n  validates :bio, length: { maximum: 500 }, allow_blank: true\nend"
      },
      {
        "id": 3403,
        "question": "Write a conceptual `update` action in a `UsersController` that handles updating both `User` attributes, nested `Profile` attributes (including `bio` and `social_links`), and all three Active Storage attachments. Include the necessary strong parameters method.",
        "correctAnswer": "```ruby\nclass UsersController < ApplicationController\n  before_action :authenticate_user! # Assumes Devise or similar for current_user\n  before_action :set_user, only: [:show, :edit, :update]\n\n  def show\n    # The @user and its @profile are available after set_user\n  end\n\n  def edit\n    @profile = @user.profile # Ensure profile is loaded for forms\n  end\n\n  def update\n    # Use nested attributes for profile, and directly handle Active Storage attachments\n    if @user.update(user_params)\n      redirect_to @user, notice: 'Profile was successfully updated.'\n    else\n      @profile = @user.profile # Re-load profile for rendering the form again on error\n      render :edit\n    end\n  end\n\n  private\n\n  def set_user\n    @user = current_user # Or User.find(params[:id]) if allowing editing other users\n  end\n\n  def user_params\n    params.require(:user).permit(\n      :username,\n      :profile_picture, # Active Storage attachment for User\n      :video_presentation, # Active Storage attachment for User\n      profile_attributes: [ # Nested attributes for the associated Profile\n        :id, # Crucial for updating an existing associated record via accepts_nested_attributes_for\n        :bio,\n        :background_image, # Active Storage attachment for Profile\n        social_links: [:twitter, :linkedin, :github] # Nested hash for JSONB\n      ]\n    )\n  end\nend\n```\n\n**Key considerations:**\n-   `accepts_nested_attributes_for :profile` is implicitly handled by Rails if you define `profile_attributes` in strong parameters and include `:id` for existing records. If the profile doesn't exist, Rails would create it. Since we create it with `after_create`, it will always exist and be updated.\n-   Active Storage attachments are permitted directly as top-level parameters for the `User` and within `profile_attributes` for the `Profile`.\n-   The `social_links` JSONB hash is permitted as a nested hash.",
        "codeExample": "class UsersController < ApplicationController\n  before_action :authenticate_user!\n  before_action :set_user, only: [:show, :edit, :update]\n\n  def update\n    if @user.update(user_params)\n      redirect_to @user, notice: 'Profile was successfully updated.'\n    else\n      @profile = @user.profile # Ensure profile is loaded for form re-render\n      render :edit\n    end\n  end\n\n  private\n\n  def set_user\n    @user = current_user # Assuming current_user is the user to be updated\n  end\n\n  def user_params\n    params.require(:user).permit(\n      :username,\n      :profile_picture,\n      :video_presentation,\n      profile_attributes: [\n        :id, \n        :bio,\n        :background_image,\n        social_links: [:twitter, :linkedin, :github]\n      ]\n    )\n  end\nend"
      },
      {
        "id": 3404,
        "question": "Describe how you would display the `profile_picture` on the user's profile page and allow a user to delete their `video_presentation` through a form. Consider both the view code and any necessary controller/model adjustments.",
        "correctAnswer": "**Displaying `profile_picture` (View):**\nIn `app/views/users/show.html.erb`:\n```erb\n<% if @user.profile_picture.attached? %>\n  <%= image_tag @user.profile_picture, size: '200x200', alt: \"#{@user.username}'s profile picture\" %>\n<% else %>\n  <p>No profile picture uploaded.</p>\n<% end %>\n```\n\n**Deleting `video_presentation` (View & Controller/Model):**\n\n**View (`app/views/users/edit.html.erb`):**\nTo delete an Active Storage attachment, you typically use a checkbox in the form with a `_destroy` attribute (if using `accepts_nested_attributes_for` for a separate attachment model) or a direct method call from the controller after checking a parameter.\n\nFor `has_one_attached`, a common pattern is to have a separate checkbox that signals deletion:\n```erb\n<% if @user.video_presentation.attached? %>\n  <p>Current video: <%= @user.video_presentation.filename %></p>\n  <%= form.check_box :remove_video_presentation %>\n  <%= form.label :remove_video_presentation, \"Remove video presentation\" %>\n<% end %>\n<%= form.file_field :video_presentation %>\n```\n\n**Controller (`app/controllers/users_controller.rb` - update action):**\nYou would need to permit `remove_video_presentation` in strong parameters and then handle the logic in the controller.\n\n```ruby\nclass UsersController < ApplicationController\n  # ... (other actions and before_actions) ...\n\n  def update\n    if user_params[:remove_video_presentation] == '1' && @user.video_presentation.attached?\n      @user.video_presentation.purge # Deletes the file\n    end\n\n    if @user.update(user_params.except(:remove_video_presentation))\n      redirect_to @user, notice: 'Profile was successfully updated.'\n    else\n      @profile = @user.profile\n      render :edit\n    end\n  end\n\n  private\n\n  def user_params\n    params.require(:user).permit(\n      :username,\n      :profile_picture,\n      :video_presentation,\n      :remove_video_presentation, # Permit this new param\n      profile_attributes: [\n        :id,\n        :bio,\n        :background_image,\n        social_links: [:twitter, :linkedin, :github]\n      ]\n    )\n  end\nend\n```\n\n**Alternative (Direct Purge):**\nFor simple deletions, especially outside a form submission, you might provide a separate `DELETE` route and action:\n\n**Routes (`config/routes.rb`):**\n`resources :users do member { delete :purge_video_presentation } end`\n\n**View (`app/views/users/show.html.erb`):**\n```erb\n<% if @user.video_presentation.attached? %>\n  <%= link_to 'Remove Video', purge_video_presentation_user_path(@user), method: :delete, data: { confirm: 'Are you sure?' } %>\n<% end %>\n```\n\n**Controller (`app/controllers/users_controller.rb`):**\n```ruby\nclass UsersController < ApplicationController\n  # ...\n  def purge_video_presentation\n    @user = current_user # Or find based on params[:id]\n    @user.video_presentation.purge # Deletes the file\n    redirect_to edit_user_path(@user), notice: 'Video presentation removed.'\n  end\nend\n```",
        "codeExample": "# --- Displaying profile_picture (View) ---\n<% if @user.profile_picture.attached? %>\n  <%= image_tag @user.profile_picture, size: '200x200', alt: \"#{@user.username}'s profile picture\" %>\n<% else %>\n  <p>No profile picture uploaded.</p>\n<% end %>\n\n# --- Deleting video_presentation (View & Controller) ---\n# In app/views/users/edit.html.erb:\n<%= form_with(model: @user, local: true) do |form| %>\n  \n\n  <% if @user.video_presentation.attached? %>\n    <p>Current video: <%= @user.video_presentation.filename %></p>\n    <%= form.check_box :remove_video_presentation %>\n    <%= form.label :remove_video_presentation, \"Remove video presentation\" %>\n  <% end %>\n  <%= form.file_field :video_presentation %>\n\n  <%= form.submit 'Update Profile' %>\n<% end %>\n\n# In app/controllers/users_controller.rb:\nclass UsersController < ApplicationController\n  # ...\n  def update\n    # Handle deletion flag before updating other attributes\n    if user_params[:remove_video_presentation] == '1' && @user.video_presentation.attached?\n      @user.video_presentation.purge # Deletes the attached file\n    end\n\n    # Update user with remaining permitted parameters\n    if @user.update(user_params.except(:remove_video_presentation))\n      redirect_to @user, notice: 'Profile was successfully updated.'\n    else\n      @profile = @user.profile # Reload profile for form\n      render :edit\n    end\n  end\n\n  private\n  def user_params\n    params.require(:user).permit(\n      :username,\n      :profile_picture,\n      :video_presentation,\n      :remove_video_presentation, # Permit this new boolean field\n      profile_attributes: [\n        :id,\n        :bio,\n        :background_image,\n        social_links: [:twitter, :linkedin, :github]\n      ]\n    )\n  end\nend"
      }
    ]
  }
];
