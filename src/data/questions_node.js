export const questions = [
  {
    "id": 1,
    "category": "Node.js Basics",
    "level": "junior",
    "title": "Event Loop",
    "question": "What is the Node.js event loop and how does it work?",
    "correctAnswer": "The event loop is the mechanism that allows Node.js to perform non-blocking I/O operations despite JavaScript being single-threaded. It continuously checks the call stack and callback queue, executing callbacks when the stack is empty. Phases include: timers, pending callbacks, idle/prepare, poll, check, and close callbacks.",
    "codeExample": "console.log('Start');\n\nsetTimeout(() => {\n  console.log('Timeout');\n}, 0);\n\nPromise.resolve().then(() => {\n  console.log('Promise');\n});\n\nconsole.log('End');\n\n// Output:\n// Start\n// End\n// Promise (microtask - higher priority)\n// Timeout (macrotask)",
    "image": "https://picsum.photos/id/30/800/400"
  },
  {
    "id": 2,
    "category": "Node.js Basics",
    "level": "junior",
    "title": "Blocking vs Non-Blocking",
    "question": "Explain the difference between blocking and non-blocking I/O in Node.js.",
    "correctAnswer": "Blocking I/O waits for the operation to complete before continuing execution, while non-blocking I/O uses callbacks, promises, or async/await to handle operations asynchronously. Node.js is designed for non-blocking operations to maintain high performance and handle concurrent requests efficiently.",
    "codeExample": "// Blocking (synchronous)\nconst fs = require('fs');\nconst data = fs.readFileSync('file.txt', 'utf8');\nconsole.log(data);\nconsole.log('After read');\n\n// Non-blocking (asynchronous)\nfs.readFile('file.txt', 'utf8', (err, data) => {\n  if (err) throw err;\n  console.log(data);\n});\nconsole.log('After read'); // Executes before file is read\n\n// With Promises\nconst fsPromises = require('fs').promises;\nfsPromises.readFile('file.txt', 'utf8')\n  .then(data => console.log(data))\n  .catch(err => console.error(err));"
  },
  {
    "id": 4,
    "category": "Express.js",
    "level": "junior",
    "title": "Middleware",
    "question": "What is middleware in Express.js and how does it work?",
    "correctAnswer": "Middleware functions have access to request (req), response (res), and next() function. They execute in sequence and can modify req/res objects, end the request-response cycle, or call next() to pass control. Types include application-level, router-level, error-handling, built-in, and third-party middleware.",
    "codeExample": "const express = require('express');\nconst app = express();\n\n// Application-level middleware\napp.use((req, res, next) => {\n  console.log('Time:', Date.now());\n  next();\n});\n\n// Built-in middleware\napp.use(express.json());\napp.use(express.urlencoded({ extended: true }));\n\n// Route-specific middleware\nconst authenticate = (req, res, next) => {\n  if (req.headers.authorization) {\n    next();\n  } else {\n    res.status(401).json({ error: 'Unauthorized' });\n  }\n};\n\napp.get('/protected', authenticate, (req, res) => {\n  res.json({ message: 'Access granted' });\n});\n\n// Error-handling middleware (4 parameters)\napp.use((err, req, res, next) => {\n  console.error(err.stack);\n  res.status(500).json({ error: err.message });\n});"
  },
  {
    "id": 3,
    "category": "Node.js Basics",
    "level": "mid",
    "title": "Streams",
    "question": "What are streams in Node.js and what are the different types?",
    "correctAnswer": "Streams are objects that let you read or write data in chunks rather than all at once. Four types: Readable (reading data), Writable (writing data), Duplex (both read and write), and Transform (modifies data while reading/writing). Benefits include memory efficiency and ability to process data before it's fully loaded.",
    "codeExample": "const fs = require('fs');\nconst zlib = require('zlib');\n\n// Readable stream\nconst readable = fs.createReadStream('input.txt');\nreadable.on('data', (chunk) => {\n  console.log(`Received ${chunk.length} bytes`);\n});\n\n// Writable stream\nconst writable = fs.createWriteStream('output.txt');\nwritable.write('Hello World\\n');\nwritable.end();\n\n// Pipe - chain streams\nfs.createReadStream('file.txt')\n  .pipe(zlib.createGzip())\n  .pipe(fs.createWriteStream('file.txt.gz'));\n\n// Transform stream\nconst { Transform } = require('stream');\nconst upperCase = new Transform({\n  transform(chunk, encoding, callback) {\n    this.push(chunk.toString().toUpperCase());\n    callback();\n  }\n});\n\nprocess.stdin.pipe(upperCase).pipe(process.stdout);"
  },
  {
    "id": 5,
    "category": "Express.js",
    "level": "mid",
    "title": "RESTful API Design",
    "question": "How do you design a RESTful API in Express.js following best practices?",
    "correctAnswer": "RESTful APIs use HTTP methods (GET, POST, PUT, PATCH, DELETE) with resource-based URLs. Best practices: use nouns for endpoints, proper status codes, versioning, consistent naming, proper error handling, HATEOAS principles, pagination for large datasets, and authentication/authorization.",
    "codeExample": "const express = require('express');\nconst router = express.Router();\n\n// GET /api/v1/users - List all users\nrouter.get('/users', async (req, res) => {\n  const { page = 1, limit = 10 } = req.query;\n  const users = await User.find()\n    .limit(limit)\n    .skip((page - 1) * limit);\n  res.json({ data: users, page, limit });\n});\n\n// GET /api/v1/users/:id - Get specific user\nrouter.get('/users/:id', async (req, res) => {\n  const user = await User.findById(req.params.id);\n  if (!user) return res.status(404).json({ error: 'Not found' });\n  res.json({ data: user });\n});\n\n// POST /api/v1/users - Create user\nrouter.post('/users', async (req, res) => {\n  const user = await User.create(req.body);\n  res.status(201).json({ data: user });\n});\n\n// PUT /api/v1/users/:id - Full update\nrouter.put('/users/:id', async (req, res) => {\n  const user = await User.findByIdAndUpdate(\n    req.params.id,\n    req.body,\n    { new: true }\n  );\n  res.json({ data: user });\n});\n\n// PATCH /api/v1/users/:id - Partial update\nrouter.patch('/users/:id', async (req, res) => {\n  const user = await User.findByIdAndUpdate(\n    req.params.id,\n    { $set: req.body },\n    { new: true }\n  );\n  res.json({ data: user });\n});\n\n// DELETE /api/v1/users/:id - Delete user\nrouter.delete('/users/:id', async (req, res) => {\n  await User.findByIdAndDelete(req.params.id);\n  res.status(204).send();\n});\n\nmodule.exports = router;"
  },
  {
    "id": 6,
    "category": "Async Programming",
    "level": "mid",
    "title": "Promises vs Async/Await",
    "question": "Explain Promises and async/await. When would you use each?",
    "correctAnswer": "Promises represent eventual completion of async operations with then/catch chains. Async/await is syntactic sugar over Promises, making async code look synchronous. Use Promises for simple chains or parallel operations with Promise.all(). Use async/await for complex logic, better error handling with try/catch, and improved readability.",
    "codeExample": "// Promises\nfunction fetchUser(id) {\n  return fetch(`/api/users/${id}`)\n    .then(res => res.json())\n    .then(user => {\n      console.log(user);\n      return user;\n    })\n    .catch(err => console.error(err));\n}\n\n// Async/Await\nasync function fetchUserAsync(id) {\n  try {\n    const res = await fetch(`/api/users/${id}`);\n    const user = await res.json();\n    console.log(user);\n    return user;\n  } catch (err) {\n    console.error(err);\n  }\n}\n\n// Parallel execution with Promise.all\nconst [users, posts, comments] = await Promise.all([\n  fetch('/api/users').then(r => r.json()),\n  fetch('/api/posts').then(r => r.json()),\n  fetch('/api/comments').then(r => r.json())\n]);\n\n// Sequential with async/await\nasync function sequential() {\n  const users = await fetchUsers();\n  const posts = await fetchPosts(users[0].id);\n  const comments = await fetchComments(posts[0].id);\n  return { users, posts, comments };\n}"
  },
  {
    "id": 8,
    "category": "Database",
    "level": "mid",
    "title": "MongoDB with Mongoose",
    "question": "How do you work with MongoDB using Mongoose in Node.js?",
    "correctAnswer": "Mongoose is an ODM (Object Data Modeling) library for MongoDB. It provides schema validation, middleware, query building, and relationships. Define schemas with types and validators, create models, and use methods like find(), create(), update(), delete(). Supports virtuals, hooks (pre/post), and population for references.",
    "codeExample": "const mongoose = require('mongoose');\n\n// Define schema\nconst userSchema = new mongoose.Schema({\n  name: {\n    type: String,\n    required: [true, 'Name is required'],\n    trim: true,\n    minlength: 2\n  },\n  email: {\n    type: String,\n    required: true,\n    unique: true,\n    lowercase: true\n  },\n  age: {\n    type: Number,\n    min: 18,\n    max: 120\n  },\n  posts: [{\n    type: mongoose.Schema.Types.ObjectId,\n    ref: 'Post'\n  }]\n}, {\n  timestamps: true\n});\n\n// Virtual property\nuserSchema.virtual('fullInfo').get(function() {\n  return `${this.name} (${this.email})`;\n});\n\n// Instance method\nuserSchema.methods.greet = function() {\n  return `Hello, I'm ${this.name}`;\n};\n\n// Static method\nuserSchema.statics.findByEmail = function(email) {\n  return this.findOne({ email });\n};\n\n// Middleware\nuserSchema.pre('save', async function(next) {\n  if (this.isModified('password')) {\n    this.password = await bcrypt.hash(this.password, 12);\n  }\n  next();\n});\n\n// Create model\nconst User = mongoose.model('User', userSchema);\n\n// Usage\nconst user = await User.create({\n  name: 'John Doe',\n  email: 'john@example.com',\n  age: 25\n});\n\n// Query\nconst users = await User.find({ age: { $gte: 18 } })\n  .select('name email')\n  .limit(10)\n  .sort('-createdAt');\n\n// Population\nconst user = await User.findById(id).populate('posts');"
  },
  {
    "id": 10,
    "category": "Authentication",
    "level": "mid",
    "title": "JWT Authentication",
    "question": "How do you implement JWT authentication in Node.js?",
    "correctAnswer": "JWT (JSON Web Tokens) are used for stateless authentication. Generate tokens on login with user payload and secret, send to client, client includes token in Authorization header. Server verifies token signature and expiry. Implement refresh tokens for security. Store tokens securely (httpOnly cookies or localStorage with precautions).",
    "codeExample": "const jwt = require('jsonwebtoken');\nconst bcrypt = require('bcrypt');\n\n// Generate token\nfunction generateToken(userId) {\n  return jwt.sign(\n    { id: userId },\n    process.env.JWT_SECRET,\n    { expiresIn: '24h' }\n  );\n}\n\n// Login route\napp.post('/api/login', async (req, res) => {\n  const { email, password } = req.body;\n\n  // Find user\n  const user = await User.findOne({ email });\n  if (!user) {\n    return res.status(401).json({ error: 'Invalid credentials' });\n  }\n\n  // Verify password\n  const isValid = await bcrypt.compare(password, user.password);\n  if (!isValid) {\n    return res.status(401).json({ error: 'Invalid credentials' });\n  }\n\n  // Generate token\n  const token = generateToken(user._id);\n\n  res.json({\n    token,\n    user: {\n      id: user._id,\n      email: user.email,\n      name: user.name\n    }\n  });\n});\n\n// Auth middleware\nconst authenticate = async (req, res, next) => {\n  try {\n    const token = req.headers.authorization?.replace('Bearer ', '');\n\n    if (!token) {\n      throw new Error('No token provided');\n    }\n\n    const decoded = jwt.verify(token, process.env.JWT_SECRET);\n    const user = await User.findById(decoded.id);\n\n    if (!user) {\n      throw new Error('User not found');\n    }\n\n    req.user = user;\n    next();\n  } catch (err) {\n    res.status(401).json({ error: 'Please authenticate' });\n  }\n};\n\n// Protected route\napp.get('/api/profile', authenticate, (req, res) => {\n  res.json({ user: req.user });\n});\n\n// Refresh token implementation\nfunction generateRefreshToken(userId) {\n  return jwt.sign(\n    { id: userId },\n    process.env.REFRESH_TOKEN_SECRET,\n    { expiresIn: '7d' }\n  );\n}\n\napp.post('/api/refresh', async (req, res) => {\n  const { refreshToken } = req.body;\n\n  try {\n    const decoded = jwt.verify(refreshToken, process.env.REFRESH_TOKEN_SECRET);\n    const newAccessToken = generateToken(decoded.id);\n    res.json({ token: newAccessToken });\n  } catch (err) {\n    res.status(401).json({ error: 'Invalid refresh token' });\n  }\n});"
  },
  {
    "id": 11,
    "category": "Testing",
    "level": "mid",
    "title": "Unit Testing with Jest",
    "question": "How do you write unit tests for Node.js applications using Jest?",
    "correctAnswer": "Jest is a testing framework with built-in mocking, assertions, and coverage. Test individual functions/modules in isolation using describe/it blocks. Mock dependencies with jest.mock(), use expect() for assertions, test edge cases and error scenarios. Use beforeEach/afterEach for setup/teardown. Test async code with async/await or done callback.",
    "codeExample": "// userService.js\nclass UserService {\n  constructor(userRepository) {\n    this.userRepository = userRepository;\n  }\n\n  async getUser(id) {\n    if (!id) throw new Error('ID is required');\n    const user = await this.userRepository.findById(id);\n    if (!user) throw new Error('User not found');\n    return user;\n  }\n\n  async createUser(data) {\n    if (!data.email) throw new Error('Email is required');\n    return await this.userRepository.create(data);\n  }\n}\n\n// userService.test.js\nconst UserService = require('./userService');\n\ndescribe('UserService', () => {\n  let userService;\n  let mockUserRepository;\n\n  beforeEach(() => {\n    mockUserRepository = {\n      findById: jest.fn(),\n      create: jest.fn()\n    };\n    userService = new UserService(mockUserRepository);\n  });\n\n  describe('getUser', () => {\n    it('should return user when found', async () => {\n      const mockUser = { id: 1, name: 'John' };\n      mockUserRepository.findById.mockResolvedValue(mockUser);\n\n      const result = await userService.getUser(1);\n\n      expect(result).toEqual(mockUser);\n      expect(mockUserRepository.findById).toHaveBeenCalledWith(1);\n    });\n\n    it('should throw error when user not found', async () => {\n      mockUserRepository.findById.mockResolvedValue(null);\n\n      await expect(userService.getUser(1))\n        .rejects.toThrow('User not found');\n    });\n\n    it('should throw error when no ID provided', async () => {\n      await expect(userService.getUser())\n        .rejects.toThrow('ID is required');\n    });\n  });\n\n  describe('createUser', () => {\n    it('should create user with valid data', async () => {\n      const userData = { email: 'test@example.com', name: 'John' };\n      const createdUser = { id: 1, ...userData };\n      mockUserRepository.create.mockResolvedValue(createdUser);\n\n      const result = await userService.createUser(userData);\n\n      expect(result).toEqual(createdUser);\n      expect(mockUserRepository.create).toHaveBeenCalledWith(userData);\n    });\n\n    it('should throw error when email missing', async () => {\n      await expect(userService.createUser({ name: 'John' }))\n        .rejects.toThrow('Email is required');\n    });\n  });\n});\n\n// Run tests\n// npm test -- --coverage"
  },
  {
    "id": 14,
    "category": "Performance",
    "level": "mid",
    "title": "Caching Strategies",
    "question": "What are effective caching strategies in Node.js?",
    "correctAnswer": "Implement multiple caching layers: in-memory (Node-cache), Redis for distributed caching, HTTP caching headers, CDN for static assets. Cache database queries, API responses, expensive computations. Use cache invalidation strategies (TTL, LRU, manual). Consider cache-aside, write-through, or write-behind patterns based on requirements.",
    "codeExample": "const NodeCache = require('node-cache');\nconst redis = require('redis');\n\n// In-memory caching\nconst cache = new NodeCache({ stdTTL: 600 }); // 10 min TTL\n\n// Redis client\nconst redisClient = redis.createClient({\n  url: process.env.REDIS_URL\n});\nawait redisClient.connect();\n\n// Cache middleware\nconst cacheMiddleware = (duration) => {\n  return async (req, res, next) => {\n    const key = req.originalUrl;\n    const cached = cache.get(key);\n\n    if (cached) {\n      return res.json(cached);\n    }\n\n    res.originalJson = res.json;\n    res.json = (body) => {\n      cache.set(key, body, duration);\n      res.originalJson(body);\n    };\n    next();\n  };\n};\n\n// Usage\napp.get('/api/users', cacheMiddleware(600), async (req, res) => {\n  const users = await User.find();\n  res.json(users);\n});\n\n// Redis caching with async/await\nasync function getCachedData(key, fetchFunction, ttl = 3600) {\n  // Try cache first\n  const cached = await redisClient.get(key);\n  if (cached) {\n    return JSON.parse(cached);\n  }\n\n  // Fetch data\n  const data = await fetchFunction();\n\n  // Store in cache\n  await redisClient.setEx(key, ttl, JSON.stringify(data));\n\n  return data;\n}\n\n// Example usage\napp.get('/api/stats', async (req, res) => {\n  const stats = await getCachedData(\n    'stats:daily',\n    async () => {\n      return await calculateDailyStats();\n    },\n    3600\n  );\n  res.json(stats);\n});\n\n// Cache invalidation\nasync function invalidateUserCache(userId) {\n  await redisClient.del(`user:${userId}`);\n  await redisClient.del('users:all');\n}\n\n// HTTP caching headers\napp.get('/api/public/data', (req, res) => {\n  res.set({\n    'Cache-Control': 'public, max-age=3600',\n    'ETag': generateETag(data)\n  });\n  res.json(data);\n});\n\n// Conditional GET (304 Not Modified)\napp.get('/api/resource', (req, res) => {\n  const etag = generateETag(resource);\n\n  if (req.headers['if-none-match'] === etag) {\n    return res.status(304).end();\n  }\n\n  res.set('ETag', etag);\n  res.json(resource);\n});"
  },
  {
    "id": 15,
    "category": "Security",
    "level": "mid",
    "title": "Security Best Practices",
    "question": "What are essential security practices for Node.js applications?",
    "correctAnswer": "Use helmet.js for HTTP headers, validate/sanitize inputs, implement rate limiting, use HTTPS, secure session management, prevent SQL/NoSQL injection, implement CORS properly, keep dependencies updated, use environment variables for secrets, implement proper error handling (don't leak stack traces), use CSP headers, implement authentication/authorization properly.",
    "codeExample": "const express = require('express');\nconst helmet = require('helmet');\nconst rateLimit = require('express-rate-limit');\nconst mongoSanitize = require('express-mongo-sanitize');\nconst xss = require('xss-clean');\nconst cors = require('cors');\n\nconst app = express();\n\n// Helmet - sets various HTTP headers\napp.use(helmet());\n\n// CORS configuration\napp.use(cors({\n  origin: process.env.ALLOWED_ORIGINS?.split(','),\n  credentials: true,\n  optionsSuccessStatus: 200\n}));\n\n// Rate limiting\nconst limiter = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  max: 100, // Limit each IP to 100 requests per window\n  message: 'Too many requests from this IP'\n});\napp.use('/api/', limiter);\n\n// Login rate limiting (stricter)\nconst loginLimiter = rateLimit({\n  windowMs: 15 * 60 * 1000,\n  max: 5,\n  message: 'Too many login attempts'\n});\napp.use('/api/login', loginLimiter);\n\n// Body parser\napp.use(express.json({ limit: '10kb' })); // Limit body size\n\n// Data sanitization against NoSQL injection\napp.use(mongoSanitize());\n\n// Data sanitization against XSS\napp.use(xss());\n\n// Input validation with express-validator\nconst { body, validationResult } = require('express-validator');\n\napp.post('/api/users',\n  [\n    body('email').isEmail().normalizeEmail(),\n    body('password')\n      .isLength({ min: 8 })\n      .matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)/)\n      .withMessage('Password must contain uppercase, lowercase, and number'),\n    body('name').trim().escape()\n  ],\n  async (req, res) => {\n    const errors = validationResult(req);\n    if (!errors.isEmpty()) {\n      return res.status(400).json({ errors: errors.array() });\n    }\n\n    // Process request\n  }\n);\n\n// Secure headers\napp.use((req, res, next) => {\n  res.setHeader('X-Content-Type-Options', 'nosniff');\n  res.setHeader('X-Frame-Options', 'DENY');\n  res.setHeader('X-XSS-Protection', '1; mode=block');\n  next();\n});\n\n// Content Security Policy\napp.use(helmet.contentSecurityPolicy({\n  directives: {\n    defaultSrc: [\"'self'\"],\n    styleSrc: [\"'self'\", \"'unsafe-inline'\"],\n    scriptSrc: [\"'self'\"],\n    imgSrc: [\"'self'\", 'data:', 'https:']\n  }\n}));\n\n// Prevent parameter pollution\nconst hpp = require('hpp');\napp.use(hpp());\n\n// Secure session cookies\nconst session = require('express-session');\napp.use(session({\n  secret: process.env.SESSION_SECRET,\n  resave: false,\n  saveUninitialized: false,\n  cookie: {\n    secure: true, // HTTPS only\n    httpOnly: true, // Not accessible via JavaScript\n    maxAge: 3600000, // 1 hour\n    sameSite: 'strict'\n  }\n}));\n\n// Don't expose technology stack\napp.disable('x-powered-by');"
  },
  {
    "id": 16,
    "category": "WebSockets",
    "level": "mid",
    "title": "Real-time with Socket.IO",
    "question": "How do you implement real-time communication using Socket.IO?",
    "correctAnswer": "Socket.IO enables bidirectional real-time communication using WebSockets (with fallbacks). Server and client establish persistent connection. Use emit() to send events, on() to listen. Supports rooms for grouping connections, namespaces for separation, middleware for authentication. Handle connection/disconnection, implement reconnection logic, and scale with Redis adapter.",
    "codeExample": "// Server setup\nconst express = require('express');\nconst http = require('http');\nconst socketIO = require('socket.io');\n\nconst app = express();\nconst server = http.createServer(app);\nconst io = socketIO(server, {\n  cors: {\n    origin: process.env.CLIENT_URL,\n    methods: ['GET', 'POST']\n  }\n});\n\n// Authentication middleware\nio.use((socket, next) => {\n  const token = socket.handshake.auth.token;\n  try {\n    const user = verifyToken(token);\n    socket.user = user;\n    next();\n  } catch (err) {\n    next(new Error('Authentication error'));\n  }\n});\n\n// Connection handling\nio.on('connection', (socket) => {\n  console.log(`User connected: ${socket.user.id}`);\n\n  // Join user to their room\n  socket.join(`user:${socket.user.id}`);\n\n  // Handle custom events\n  socket.on('message', async (data) => {\n    const message = await Message.create({\n      text: data.text,\n      userId: socket.user.id,\n      roomId: data.roomId\n    });\n\n    // Broadcast to room\n    io.to(data.roomId).emit('newMessage', message);\n  });\n\n  // Join chat room\n  socket.on('joinRoom', (roomId) => {\n    socket.join(roomId);\n    socket.to(roomId).emit('userJoined', {\n      userId: socket.user.id,\n      name: socket.user.name\n    });\n  });\n\n  // Leave room\n  socket.on('leaveRoom', (roomId) => {\n    socket.leave(roomId);\n    socket.to(roomId).emit('userLeft', socket.user.id);\n  });\n\n  // Typing indicator\n  socket.on('typing', (roomId) => {\n    socket.to(roomId).emit('userTyping', socket.user.name);\n  });\n\n  // Disconnect\n  socket.on('disconnect', () => {\n    console.log(`User disconnected: ${socket.user.id}`);\n  });\n});\n\n// Emit from server routes\napp.post('/api/notifications', async (req, res) => {\n  const notification = await Notification.create(req.body);\n\n  // Send to specific user\n  io.to(`user:${req.body.userId}`).emit('notification', notification);\n\n  res.json(notification);\n});\n\nserver.listen(3000);\n\n// Client implementation\nimport { io } from 'socket.io-client';\n\nconst socket = io('http://localhost:3000', {\n  auth: {\n    token: localStorage.getItem('token')\n  }\n});\n\nsocket.on('connect', () => {\n  console.log('Connected');\n  socket.emit('joinRoom', 'room123');\n});\n\nsocket.on('newMessage', (message) => {\n  console.log('New message:', message);\n  addMessageToUI(message);\n});\n\nsocket.on('disconnect', () => {\n  console.log('Disconnected');\n});\n\n// Send message\nfunction sendMessage(text, roomId) {\n  socket.emit('message', { text, roomId });\n}\n\n// Scaling with Redis (for multiple servers)\nconst RedisAdapter = require('@socket.io/redis-adapter');\nconst { createClient } = require('redis');\n\nconst pubClient = createClient({ url: 'redis://localhost:6379' });\nconst subClient = pubClient.duplicate();\n\nPromise.all([pubClient.connect(), subClient.connect()]).then(() => {\n  io.adapter(RedisAdapter(pubClient, subClient));\n});"
  },
  {
    "id": 19,
    "category": "GraphQL",
    "level": "mid",
    "title": "GraphQL with Apollo Server",
    "question": "How do you implement GraphQL API using Apollo Server?",
    "correctAnswer": "Apollo Server is a GraphQL server for Node.js. Define schema with type definitions and resolvers. Benefits: fetch exactly what you need, single endpoint, strong typing, introspection. Implement queries, mutations, subscriptions. Use DataLoader for batching, implement authentication context, handle errors, add caching, and pagination.",
    "codeExample": "const { ApolloServer, gql } = require('apollo-server-express');\nconst express = require('express');\nconst DataLoader = require('dataloader');\n\n// Type definitions\nconst typeDefs = gql`\n  type User {\n    id: ID!\n    name: String!\n    email: String!\n    posts: [Post!]!\n  }\n\n  type Post {\n    id: ID!\n    title: String!\n    content: String!\n    author: User!\n    comments: [Comment!]!\n  }\n\n  type Comment {\n    id: ID!\n    text: String!\n    author: User!\n  }\n\n  type Query {\n    user(id: ID!): User\n    users(limit: Int, offset: Int): [User!]!\n    post(id: ID!): Post\n    posts: [Post!]!\n  }\n\n  type Mutation {\n    createUser(name: String!, email: String!): User!\n    createPost(title: String!, content: String!): Post!\n    updatePost(id: ID!, title: String, content: String): Post!\n    deletePost(id: ID!): Boolean!\n  }\n\n  type Subscription {\n    postAdded: Post!\n  }\n`;\n\n// Resolvers\nconst resolvers = {\n  Query: {\n    user: async (_, { id }, { dataSources }) => {\n      return await dataSources.userAPI.getUserById(id);\n    },\n    users: async (_, { limit = 10, offset = 0 }, { dataSources }) => {\n      return await dataSources.userAPI.getUsers(limit, offset);\n    },\n    post: async (_, { id }, { dataSources }) => {\n      return await dataSources.postAPI.getPostById(id);\n    },\n    posts: async (_, __, { dataSources }) => {\n      return await dataSources.postAPI.getAllPosts();\n    }\n  },\n\n  Mutation: {\n    createUser: async (_, { name, email }, { dataSources, user }) => {\n      if (!user) throw new Error('Not authenticated');\n      return await dataSources.userAPI.createUser({ name, email });\n    },\n    createPost: async (_, { title, content }, { dataSources, user }) => {\n      if (!user) throw new Error('Not authenticated');\n      return await dataSources.postAPI.createPost({\n        title,\n        content,\n        authorId: user.id\n      });\n    },\n    updatePost: async (_, { id, ...updates }, { dataSources, user }) => {\n      if (!user) throw new Error('Not authenticated');\n      return await dataSources.postAPI.updatePost(id, updates);\n    },\n    deletePost: async (_, { id }, { dataSources, user }) => {\n      if (!user) throw new Error('Not authenticated');\n      await dataSources.postAPI.deletePost(id);\n      return true;\n    }\n  },\n\n  // Field resolvers\n  User: {\n    posts: async (user, _, { dataSources }) => {\n      return await dataSources.postAPI.getPostsByUserId(user.id);\n    }\n  },\n\n  Post: {\n    author: async (post, _, { loaders }) => {\n      return await loaders.userLoader.load(post.authorId);\n    },\n    comments: async (post, _, { dataSources }) => {\n      return await dataSources.commentAPI.getCommentsByPostId(post.id);\n    }\n  },\n\n  Comment: {\n    author: async (comment, _, { loaders }) => {\n      return await loaders.userLoader.load(comment.authorId);\n    }\n  },\n\n  Subscription: {\n    postAdded: {\n      subscribe: (_, __, { pubsub }) => pubsub.asyncIterator(['POST_ADDED'])\n    }\n  }\n};\n\n// DataLoader for batching\nfunction createUserLoader() {\n  return new DataLoader(async (userIds) => {\n    const users = await User.find({ _id: { $in: userIds } });\n    const userMap = {};\n    users.forEach(user => {\n      userMap[user.id] = user;\n    });\n    return userIds.map(id => userMap[id]);\n  });\n}\n\n// Context function\nconst context = async ({ req }) => {\n  const token = req.headers.authorization?.replace('Bearer ', '');\n  let user = null;\n\n  if (token) {\n    try {\n      user = await verifyToken(token);\n    } catch (err) {\n      console.error('Invalid token');\n    }\n  }\n\n  return {\n    user,\n    loaders: {\n      userLoader: createUserLoader()\n    }\n  };\n};\n\n// Create Apollo Server\nconst app = express();\nconst server = new ApolloServer({\n  typeDefs,\n  resolvers,\n  context,\n  formatError: (err) => {\n    console.error(err);\n    return err;\n  },\n  plugins: [\n    {\n      requestDidStart(requestContext) {\n        console.log('Request started:', requestContext.request.query);\n      }\n    }\n  ]\n});\n\nawait server.start();\nserver.applyMiddleware({ app, path: '/graphql' });\n\napp.listen(4000, () => {\n  console.log('Server ready at http://localhost:4000/graphql');\n});\n\n// Client query example\n/*\nquery GetUserWithPosts {\n  user(id: \"123\") {\n    name\n    email\n    posts {\n      title\n      comments {\n        text\n        author {\n          name\n        }\n      }\n    }\n  }\n}\n\nmutation CreatePost {\n  createPost(title: \"Hello\", content: \"World\") {\n    id\n    title\n  }\n}\n*/"
  },
  {
    "id": 20,
    "category": "TypeScript",
    "level": "mid",
    "title": "TypeScript with Node.js",
    "question": "How do you use TypeScript in Node.js applications?",
    "correctAnswer": "TypeScript adds static typing to JavaScript. Configure with tsconfig.json, use types for parameters/returns, interfaces for objects, generics for reusable code. Benefits: catch errors at compile time, better IDE support, improved refactoring, self-documenting code. Use @types packages for libraries, compile to JavaScript for runtime.",
    "codeExample": "// tsconfig.json\n/*\n{\n  \"compilerOptions\": {\n    \"target\": \"ES2020\",\n    \"module\": \"commonjs\",\n    \"lib\": [\"ES2020\"],\n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./src\",\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"skipLibCheck\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"resolveJsonModule\": true,\n    \"declaration\": true\n  },\n  \"include\": [\"src/**/*\"],\n  \"exclude\": [\"node_modules\", \"dist\"]\n}\n*/\n\n// Types and Interfaces\ninterface User {\n  id: string;\n  name: string;\n  email: string;\n  age?: number; // Optional\n  readonly createdAt: Date; // Read-only\n}\n\ninterface UserRepository {\n  findById(id: string): Promise<User | null>;\n  create(data: CreateUserDTO): Promise<User>;\n  update(id: string, data: Partial<User>): Promise<User>;\n}\n\ntype CreateUserDTO = Omit<User, 'id' | 'createdAt'>;\ntype UpdateUserDTO = Partial<CreateUserDTO>;\n\n// Class with types\nclass UserService implements UserRepository {\n  constructor(private db: Database) {}\n\n  async findById(id: string): Promise<User | null> {\n    const user = await this.db.users.findOne({ id });\n    return user;\n  }\n\n  async create(data: CreateUserDTO): Promise<User> {\n    const user: User = {\n      ...data,\n      id: generateId(),\n      createdAt: new Date()\n    };\n    await this.db.users.insert(user);\n    return user;\n  }\n\n  async update(id: string, data: UpdateUserDTO): Promise<User> {\n    const user = await this.findById(id);\n    if (!user) throw new Error('User not found');\n\n    const updated = { ...user, ...data };\n    await this.db.users.update(id, updated);\n    return updated;\n  }\n}\n\n// Express with TypeScript\nimport express, { Request, Response, NextFunction } from 'express';\n\ninterface AuthRequest extends Request {\n  user?: User;\n}\n\nconst authenticate = async (\n  req: AuthRequest,\n  res: Response,\n  next: NextFunction\n): Promise<void> => {\n  try {\n    const token = req.headers.authorization?.replace('Bearer ', '');\n    if (!token) {\n      res.status(401).json({ error: 'No token' });\n      return;\n    }\n\n    req.user = await verifyToken(token);\n    next();\n  } catch (err) {\n    res.status(401).json({ error: 'Invalid token' });\n  }\n};\n\nconst app = express();\n\napp.get('/users/:id', authenticate, async (\n  req: AuthRequest,\n  res: Response\n): Promise<void> => {\n  const user = await userService.findById(req.params.id);\n  if (!user) {\n    res.status(404).json({ error: 'Not found' });\n    return;\n  }\n  res.json(user);\n});\n\n// Generics\nclass Repository<T extends { id: string }> {\n  constructor(private collection: string) {}\n\n  async findById(id: string): Promise<T | null> {\n    return await db.collection(this.collection).findOne({ id });\n  }\n\n  async findAll(): Promise<T[]> {\n    return await db.collection(this.collection).find({});\n  }\n\n  async create(data: Omit<T, 'id'>): Promise<T> {\n    const item = { ...data, id: generateId() } as T;\n    await db.collection(this.collection).insert(item);\n    return item;\n  }\n}\n\nconst userRepo = new Repository<User>('users');\nconst postRepo = new Repository<Post>('posts');\n\n// Utility types\ntype ApiResponse<T> = {\n  success: boolean;\n  data?: T;\n  error?: string;\n};\n\nasync function fetchUser(id: string): Promise<ApiResponse<User>> {\n  try {\n    const user = await userService.findById(id);\n    return { success: true, data: user };\n  } catch (err) {\n    return { success: false, error: err.message };\n  }\n}\n\n// Enums\nenum UserRole {\n  Admin = 'ADMIN',\n  User = 'USER',\n  Guest = 'GUEST'\n}\n\ninterface UserWithRole extends User {\n  role: UserRole;\n}\n\n// Type guards\nfunction isUser(obj: any): obj is User {\n  return obj && typeof obj.id === 'string' && typeof obj.email === 'string';\n}\n\n// Package.json scripts\n/*\n{\n  \"scripts\": {\n    \"build\": \"tsc\",\n    \"dev\": \"ts-node-dev --respawn src/index.ts\",\n    \"start\": \"node dist/index.js\",\n    \"test\": \"jest\"\n  }\n}\n*/"
  },
  {
    "id": 7,
    "category": "Async Programming",
    "level": "senior",
    "title": "Error Handling Patterns",
    "question": "What are best practices for error handling in Node.js applications?",
    "correctAnswer": "Use try/catch for async/await, .catch() for Promises, error-first callbacks for traditional Node.js patterns. Implement centralized error handling middleware in Express. Handle uncaught exceptions and unhandled rejections at process level. Create custom error classes for different error types. Log errors appropriately and return user-friendly messages.",
    "codeExample": "// Custom error classes\nclass AppError extends Error {\n  constructor(message, statusCode) {\n    super(message);\n    this.statusCode = statusCode;\n    this.isOperational = true;\n    Error.captureStackTrace(this, this.constructor);\n  }\n}\n\nclass ValidationError extends AppError {\n  constructor(message) {\n    super(message, 400);\n  }\n}\n\n// Async error wrapper\nconst catchAsync = (fn) => {\n  return (req, res, next) => {\n    fn(req, res, next).catch(next);\n  };\n};\n\n// Route handler\napp.get('/users/:id', catchAsync(async (req, res, next) => {\n  const user = await User.findById(req.params.id);\n  if (!user) {\n    throw new AppError('User not found', 404);\n  }\n  res.json({ data: user });\n}));\n\n// Global error handler\napp.use((err, req, res, next) => {\n  err.statusCode = err.statusCode || 500;\n  err.status = err.status || 'error';\n\n  if (process.env.NODE_ENV === 'development') {\n    res.status(err.statusCode).json({\n      status: err.status,\n      error: err,\n      message: err.message,\n      stack: err.stack\n    });\n  } else {\n    // Production - don't leak error details\n    if (err.isOperational) {\n      res.status(err.statusCode).json({\n        status: err.status,\n        message: err.message\n      });\n    } else {\n      console.error('ERROR:', err);\n      res.status(500).json({\n        status: 'error',\n        message: 'Something went wrong'\n      });\n    }\n  }\n});\n\n// Process-level error handlers\nprocess.on('uncaughtException', (err) => {\n  console.error('UNCAUGHT EXCEPTION! Shutting down...');\n  console.error(err.name, err.message);\n  process.exit(1);\n});\n\nprocess.on('unhandledRejection', (err) => {\n  console.error('UNHANDLED REJECTION! Shutting down...');\n  console.error(err.name, err.message);\n  server.close(() => process.exit(1));\n});"
  },
  {
    "id": 9,
    "category": "Database",
    "level": "senior",
    "title": "Query Optimization",
    "question": "How do you optimize database queries in Node.js applications?",
    "correctAnswer": "Use indexes for frequently queried fields, select only needed fields, use pagination, implement caching (Redis), use connection pooling, avoid N+1 queries with proper population/joins, use aggregation pipeline for complex queries, monitor query performance, and implement database-level constraints.",
    "codeExample": "// Create indexes\nuserSchema.index({ email: 1 }); // Single field\nuserSchema.index({ lastName: 1, firstName: 1 }); // Compound\nuserSchema.index({ location: '2dsphere' }); // Geospatial\n\n// Select specific fields\nconst users = await User.find()\n  .select('name email -_id') // Include name, email; exclude _id\n  .lean(); // Return plain JS objects (faster)\n\n// Pagination\nasync function getPaginatedUsers(page = 1, limit = 10) {\n  const skip = (page - 1) * limit;\n  const [users, total] = await Promise.all([\n    User.find().skip(skip).limit(limit),\n    User.countDocuments()\n  ]);\n  return {\n    users,\n    totalPages: Math.ceil(total / limit),\n    currentPage: page\n  };\n}\n\n// Avoid N+1 with population\n// Bad: N+1 queries\nconst users = await User.find();\nfor (let user of users) {\n  user.posts = await Post.find({ userId: user._id }); // N queries\n}\n\n// Good: Eager loading\nconst users = await User.find().populate('posts');\n\n// Aggregation pipeline\nconst stats = await User.aggregate([\n  { $match: { active: true } },\n  { $group: {\n    _id: '$country',\n    count: { $sum: 1 },\n    avgAge: { $avg: '$age' }\n  }},\n  { $sort: { count: -1 } },\n  { $limit: 10 }\n]);\n\n// Redis caching\nconst redis = require('redis');\nconst client = redis.createClient();\n\nasync function getCachedUser(id) {\n  const cached = await client.get(`user:${id}`);\n  if (cached) return JSON.parse(cached);\n\n  const user = await User.findById(id);\n  await client.setex(`user:${id}`, 3600, JSON.stringify(user));\n  return user;\n}\n\n// Connection pooling (MongoDB)\nmongoose.connect(process.env.MONGO_URI, {\n  maxPoolSize: 10,\n  minPoolSize: 5\n});"
  },
  {
    "id": 12,
    "category": "Testing",
    "level": "senior",
    "title": "Integration Testing",
    "question": "How do you write integration tests for Express APIs?",
    "correctAnswer": "Integration tests verify multiple components work together. Use supertest to make HTTP requests to your Express app, set up test database, seed data before tests, clean up after. Test complete request/response cycles, authentication flows, database interactions. Use beforeAll/afterAll for setup/teardown. Mock external services but test real database interactions.",
    "codeExample": "// app.test.js\nconst request = require('supertest');\nconst mongoose = require('mongoose');\nconst app = require('./app');\nconst User = require('./models/User');\n\nbeforeAll(async () => {\n  await mongoose.connect(process.env.TEST_DB_URL);\n});\n\nafterAll(async () => {\n  await mongoose.connection.close();\n});\n\nbeforeEach(async () => {\n  await User.deleteMany({});\n});\n\ndescribe('User API', () => {\n  describe('POST /api/users', () => {\n    it('should create a new user', async () => {\n      const userData = {\n        name: 'John Doe',\n        email: 'john@example.com',\n        password: 'password123'\n      };\n\n      const response = await request(app)\n        .post('/api/users')\n        .send(userData)\n        .expect(201);\n\n      expect(response.body.data.name).toBe(userData.name);\n      expect(response.body.data.email).toBe(userData.email);\n      expect(response.body.data.password).toBeUndefined();\n\n      const user = await User.findOne({ email: userData.email });\n      expect(user).toBeTruthy();\n    });\n\n    it('should return 400 for invalid email', async () => {\n      const response = await request(app)\n        .post('/api/users')\n        .send({ name: 'John', email: 'invalid' })\n        .expect(400);\n\n      expect(response.body.error).toBeDefined();\n    });\n\n    it('should return 409 for duplicate email', async () => {\n      const userData = {\n        name: 'John Doe',\n        email: 'john@example.com',\n        password: 'password123'\n      };\n\n      await User.create(userData);\n\n      await request(app)\n        .post('/api/users')\n        .send(userData)\n        .expect(409);\n    });\n  });\n\n  describe('GET /api/users/:id', () => {\n    it('should return user when authenticated', async () => {\n      const user = await User.create({\n        name: 'John Doe',\n        email: 'john@example.com',\n        password: 'hashed'\n      });\n\n      const token = generateToken(user._id);\n\n      const response = await request(app)\n        .get(`/api/users/${user._id}`)\n        .set('Authorization', `Bearer ${token}`)\n        .expect(200);\n\n      expect(response.body.data.name).toBe(user.name);\n    });\n\n    it('should return 401 when not authenticated', async () => {\n      await request(app)\n        .get('/api/users/123')\n        .expect(401);\n    });\n\n    it('should return 404 when user not found', async () => {\n      const token = generateToken('123');\n      const fakeId = new mongoose.Types.ObjectId();\n\n      await request(app)\n        .get(`/api/users/${fakeId}`)\n        .set('Authorization', `Bearer ${token}`)\n        .expect(404);\n    });\n  });\n});\n\n// Test helpers\nfunction generateToken(userId) {\n  return jwt.sign({ id: userId }, process.env.JWT_SECRET);\n}"
  },
  {
    "id": 13,
    "category": "Performance",
    "level": "senior",
    "title": "Clustering and Load Balancing",
    "question": "How do you scale Node.js applications using clustering?",
    "correctAnswer": "Node.js runs on single thread by default. Use cluster module to create worker processes that share the same server port, utilizing all CPU cores. Master process manages workers, handles crashes, and distributes load. Each worker runs separate instance of application. Alternative: PM2 for production with built-in clustering, monitoring, and zero-downtime deployment.",
    "codeExample": "// cluster.js\nconst cluster = require('cluster');\nconst os = require('os');\nconst express = require('express');\n\nconst numCPUs = os.cpus().length;\n\nif (cluster.isMaster) {\n  console.log(`Master process ${process.pid} is running`);\n\n  // Fork workers for each CPU\n  for (let i = 0; i < numCPUs; i++) {\n    cluster.fork();\n  }\n\n  // Replace dead workers\n  cluster.on('exit', (worker, code, signal) => {\n    console.log(`Worker ${worker.process.pid} died`);\n    console.log('Starting a new worker');\n    cluster.fork();\n  });\n\n  // Handle graceful shutdown\n  process.on('SIGTERM', () => {\n    console.log('Master received SIGTERM, shutting down...');\n    for (const id in cluster.workers) {\n      cluster.workers[id].kill();\n    }\n  });\n} else {\n  // Worker process\n  const app = express();\n\n  app.get('/', (req, res) => {\n    res.send(`Response from worker ${process.pid}`);\n  });\n\n  app.get('/heavy', (req, res) => {\n    // Simulate CPU-intensive task\n    let sum = 0;\n    for (let i = 0; i < 1e9; i++) {\n      sum += i;\n    }\n    res.json({ sum, worker: process.pid });\n  });\n\n  const server = app.listen(3000, () => {\n    console.log(`Worker ${process.pid} started`);\n  });\n\n  // Graceful shutdown for worker\n  process.on('SIGTERM', () => {\n    console.log(`Worker ${process.pid} shutting down`);\n    server.close(() => {\n      process.exit(0);\n    });\n  });\n}\n\n// Using PM2 (ecosystem.config.js)\nmodule.exports = {\n  apps: [{\n    name: 'api',\n    script: './server.js',\n    instances: 'max', // Use all CPUs\n    exec_mode: 'cluster',\n    max_memory_restart: '1G',\n    env: {\n      NODE_ENV: 'production',\n      PORT: 3000\n    }\n  }]\n};\n\n// PM2 commands:\n// pm2 start ecosystem.config.js\n// pm2 reload api         # Zero-downtime reload\n// pm2 scale api +2       # Add 2 more instances\n// pm2 monit              # Monitoring"
  },
  {
    "id": 17,
    "category": "Deployment",
    "level": "senior",
    "title": "Production Deployment",
    "question": "What are best practices for deploying Node.js to production?",
    "correctAnswer": "Use process managers (PM2), implement logging (Winston/Morgan), monitoring (New Relic/Datadog), error tracking (Sentry), environment variables, HTTPS, load balancing (nginx), database connection pooling, graceful shutdown, health checks, CI/CD pipelines, containerization (Docker), orchestration (Kubernetes), proper error handling, and performance optimization.",
    "codeExample": "// server.js - Production-ready setup\nconst express = require('express');\nconst helmet = require('helmet');\nconst morgan = require('morgan');\nconst winston = require('winston');\n\n// Logger configuration\nconst logger = winston.createLogger({\n  level: process.env.LOG_LEVEL || 'info',\n  format: winston.format.combine(\n    winston.format.timestamp(),\n    winston.format.errors({ stack: true }),\n    winston.format.json()\n  ),\n  transports: [\n    new winston.transports.File({ filename: 'error.log', level: 'error' }),\n    new winston.transports.File({ filename: 'combined.log' })\n  ]\n});\n\nif (process.env.NODE_ENV !== 'production') {\n  logger.add(new winston.transports.Console({\n    format: winston.format.simple()\n  }));\n}\n\nconst app = express();\n\n// Security\napp.use(helmet());\n\n// Request logging\napp.use(morgan('combined', {\n  stream: { write: message => logger.info(message.trim()) }\n}));\n\n// Health check\napp.get('/health', (req, res) => {\n  res.json({\n    status: 'ok',\n    timestamp: new Date().toISOString(),\n    uptime: process.uptime()\n  });\n});\n\n// Graceful shutdown\nlet server;\nconst gracefulShutdown = () => {\n  logger.info('Received shutdown signal, closing server...');\n\n  server.close(() => {\n    logger.info('HTTP server closed');\n\n    // Close database connections\n    mongoose.connection.close(false, () => {\n      logger.info('MongoDB connection closed');\n      process.exit(0);\n    });\n  });\n\n  // Force shutdown after 10 seconds\n  setTimeout(() => {\n    logger.error('Forced shutdown');\n    process.exit(1);\n  }, 10000);\n};\n\nprocess.on('SIGTERM', gracefulShutdown);\nprocess.on('SIGINT', gracefulShutdown);\n\n// Start server\nconst PORT = process.env.PORT || 3000;\nserver = app.listen(PORT, () => {\n  logger.info(`Server running on port ${PORT}`);\n});\n\n// Dockerfile\n/*\nFROM node:18-alpine\nWORKDIR /app\nCOPY package*.json ./\nRUN npm ci --only=production\nCOPY . .\nUSER node\nEXPOSE 3000\nCMD [\"node\", \"server.js\"]\n*/\n\n// docker-compose.yml\n/*\nversion: '3.8'\nservices:\n  app:\n    build: .\n    ports:\n      - \"3000:3000\"\n    environment:\n      - NODE_ENV=production\n      - MONGODB_URI=mongodb://mongo:27017/myapp\n    depends_on:\n      - mongo\n    restart: unless-stopped\n\n  mongo:\n    image: mongo:6\n    volumes:\n      - mongo-data:/data/db\n\n  nginx:\n    image: nginx:alpine\n    ports:\n      - \"80:80\"\n      - \"443:443\"\n    volumes:\n      - ./nginx.conf:/etc/nginx/nginx.conf\n    depends_on:\n      - app\n\nvolumes:\n  mongo-data:\n*/\n\n// nginx.conf\n/*\nupstream app {\n  least_conn;\n  server app:3000;\n}\n\nserver {\n  listen 80;\n  server_name example.com;\n\n  location / {\n    proxy_pass http://app;\n    proxy_http_version 1.1;\n    proxy_set_header Upgrade $http_upgrade;\n    proxy_set_header Connection 'upgrade';\n    proxy_set_header Host $host;\n    proxy_set_header X-Real-IP $remote_addr;\n    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n    proxy_cache_bypass $http_upgrade;\n  }\n}\n*/\n\n// CI/CD Pipeline (.github/workflows/deploy.yml)\n/*\nname: Deploy\non:\n  push:\n    branches: [main]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n      - uses: actions/setup-node@v2\n        with:\n          node-version: '18'\n      - run: npm ci\n      - run: npm test\n\n  deploy:\n    needs: test\n    runs-on: ubuntu-latest\n    steps:\n      - name: Deploy to production\n        run: |\n          ssh user@server 'cd /app && git pull && npm ci && pm2 reload all'\n*/"
  },
  {
    "id": 18,
    "category": "Microservices",
    "level": "senior",
    "title": "Microservices Architecture",
    "question": "How do you design microservices with Node.js?",
    "correctAnswer": "Microservices are independent services that communicate via APIs (REST/GraphQL) or message queues. Each service has its own database, follows single responsibility principle. Use API gateway for routing, service discovery for dynamic service locations, circuit breakers for fault tolerance, distributed tracing, centralized logging, and implement eventual consistency patterns.",
    "codeExample": "// Service structure\n/*\nproject/\n   services/\n      user-service/\n         src/\n         package.json\n         Dockerfile\n      order-service/\n         src/\n         package.json\n         Dockerfile\n      notification-service/\n          src/\n          package.json\n          Dockerfile\n   api-gateway/\n*/\n\n// API Gateway (using express-gateway or custom)\nconst express = require('express');\nconst { createProxyMiddleware } = require('http-proxy-middleware');\n\nconst app = express();\n\n// Service routes\napp.use('/api/users', createProxyMiddleware({\n  target: process.env.USER_SERVICE_URL,\n  changeOrigin: true\n}));\n\napp.use('/api/orders', createProxyMiddleware({\n  target: process.env.ORDER_SERVICE_URL,\n  changeOrigin: true\n}));\n\n// User Service\nconst express = require('express');\nconst amqp = require('amqplib');\n\nconst app = express();\n\n// Publish event to message queue\nasync function publishEvent(event, data) {\n  const connection = await amqp.connect(process.env.RABBITMQ_URL);\n  const channel = await connection.createChannel();\n  const exchange = 'events';\n\n  await channel.assertExchange(exchange, 'fanout', { durable: true });\n  channel.publish(exchange, '', Buffer.from(JSON.stringify({\n    event,\n    data,\n    timestamp: new Date()\n  })));\n\n  await channel.close();\n  await connection.close();\n}\n\napp.post('/users', async (req, res) => {\n  const user = await User.create(req.body);\n\n  // Publish event\n  await publishEvent('user.created', {\n    userId: user.id,\n    email: user.email\n  });\n\n  res.status(201).json(user);\n});\n\n// Notification Service - Event consumer\nasync function consumeEvents() {\n  const connection = await amqp.connect(process.env.RABBITMQ_URL);\n  const channel = await connection.createChannel();\n  const exchange = 'events';\n  const queue = 'notification-service';\n\n  await channel.assertExchange(exchange, 'fanout', { durable: true });\n  await channel.assertQueue(queue, { durable: true });\n  await channel.bindQueue(queue, exchange, '');\n\n  channel.consume(queue, async (msg) => {\n    const { event, data } = JSON.parse(msg.content.toString());\n\n    if (event === 'user.created') {\n      await sendWelcomeEmail(data.email);\n    } else if (event === 'order.placed') {\n      await sendOrderConfirmation(data);\n    }\n\n    channel.ack(msg);\n  });\n}\n\nconsumeEvents();\n\n// Service-to-service communication with retry\nconst axios = require('axios');\nconst axiosRetry = require('axios-retry');\n\nconst client = axios.create({\n  timeout: 5000\n});\n\naxiosRetry(client, {\n  retries: 3,\n  retryDelay: axiosRetry.exponentialDelay\n});\n\nasync function getUserProfile(userId) {\n  try {\n    const response = await client.get(\n      `${process.env.USER_SERVICE_URL}/users/${userId}`\n    );\n    return response.data;\n  } catch (err) {\n    logger.error('Failed to fetch user', err);\n    throw err;\n  }\n}\n\n// Circuit breaker pattern\nconst CircuitBreaker = require('opossum');\n\nconst breaker = new CircuitBreaker(getUserProfile, {\n  timeout: 3000,\n  errorThresholdPercentage: 50,\n  resetTimeout: 30000\n});\n\nbreaker.fallback(() => ({ id: null, name: 'Unknown User' }));\n\nbreaker.on('open', () => {\n  logger.warn('Circuit breaker opened');\n});\n\n// Service discovery with Consul\nconst Consul = require('consul');\nconst consul = new Consul({\n  host: process.env.CONSUL_HOST\n});\n\n// Register service\nasync function registerService() {\n  await consul.agent.service.register({\n    name: 'user-service',\n    address: process.env.SERVICE_HOST,\n    port: parseInt(process.env.SERVICE_PORT),\n    check: {\n      http: `http://${process.env.SERVICE_HOST}:${process.env.SERVICE_PORT}/health`,\n      interval: '10s'\n    }\n  });\n}\n\n// Discover service\nasync function getServiceUrl(serviceName) {\n  const services = await consul.health.service({\n    service: serviceName,\n    passing: true\n  });\n\n  if (services.length === 0) {\n    throw new Error(`No healthy instances of ${serviceName}`);\n  }\n\n  const service = services[0].Service;\n  return `http://${service.Address}:${service.Port}`;\n}"
  }
];
