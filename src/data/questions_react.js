export const questions = [
  {
    "id": 1,
    "category": "React Basics",
    "level": "junior",
    "title": "Components & JSX",
    "question": "What are React components and JSX? Explain the difference between functional and class components.",
    "correctAnswer": "Components are reusable UI building blocks that return JSX (JavaScript XML syntax). Functional components are simple functions that return JSX. Class components use ES6 classes with render() method. Modern React favors functional components with hooks.",
    "codeExample": "// Functional Component\nfunction Welcome({ name }) {\n  return <h1>Hello, {name}!</h1>;\n}\n\n// Arrow function style\nconst Welcome = ({ name }) => {\n  return <h1>Hello, {name}!</h1>;\n};\n\n// Class Component\nclass Welcome extends React.Component {\n  render() {\n    return <h1>Hello, {this.props.name}!</h1>;\n  }\n}\n\n// JSX transpiles to:\nReact.createElement('h1', null, 'Hello, ', name, '!');\n\n// Usage\n<Welcome name=\"John\" />",
    "image": ""
  },
  {
    "id": 2,
    "category": "React Basics",
    "level": "junior",
    "title": "Props vs State",
    "question": "Explain the difference between props and state in React.",
    "correctAnswer": "Props are read-only data passed from parent to child components. State is mutable data managed within a component that can change over time, triggering re-renders. Props flow down (unidirectional), state is local to component.",
    "codeExample": "// Props - passed from parent\nfunction UserCard({ name, email }) {\n  return (\n    <div>\n      <h2>{name}</h2>\n      <p>{email}</p>\n    </div>\n  );\n}\n\n// Parent passes props\n<UserCard name=\"John\" email=\"john@example.com\" />\n\n// State - managed internally\nimport { useState } from 'react';\n\nfunction Counter() {\n  const [count, setCount] = useState(0);\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(count + 1)}>\n        Increment\n      </button>\n    </div>\n  );\n}"
  },
  {
    "id": 3,
    "category": "Hooks",
    "level": "mid",
    "title": "useState & useEffect",
    "question": "Explain useState and useEffect hooks and their use cases.",
    "correctAnswer": "useState manages component state. Returns [value, setter]. useEffect handles side effects (API calls, subscriptions, DOM updates). Runs after render, with cleanup function. Dependency array controls when it runs.",
    "codeExample": "import { useState, useEffect } from 'react';\n\nfunction UserProfile({ userId }) {\n  const [user, setUser] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    let cancelled = false;\n\n    async function fetchUser() {\n      try {\n        setLoading(true);\n        const response = await fetch(`/api/users/${userId}`);\n        const data = await response.json();\n\n        if (!cancelled) {\n          setUser(data);\n          setError(null);\n        }\n      } catch (err) {\n        if (!cancelled) {\n          setError(err.message);\n        }\n      } finally {\n        if (!cancelled) {\n          setLoading(false);\n        }\n      }\n    }\n\n    fetchUser();\n\n    // Cleanup function\n    return () => {\n      cancelled = true;\n    };\n  }, [userId]); // Re-run when userId changes\n\n  if (loading) return <div>Loading...</div>;\n  if (error) return <div>Error: {error}</div>;\n\n  return (\n    <div>\n      <h1>{user.name}</h1>\n      <p>{user.email}</p>\n    </div>\n  );\n}"
  },
  {
    "id": 4,
    "category": "Hooks",
    "level": "mid",
    "title": "useCallback & useMemo",
    "question": "When and why would you use useCallback and useMemo?",
    "correctAnswer": "useCallback memoizes functions to prevent recreation on re-renders. useMemo memoizes computed values. Use for performance optimization when passing callbacks to child components or computing expensive values. Only optimize when necessary.",
    "codeExample": "import { useState, useCallback, useMemo, memo } from 'react';\n\nfunction ParentComponent() {\n  const [count, setCount] = useState(0);\n  const [filter, setFilter] = useState('');\n  const [items] = useState(Array.from({ length: 10000 }, (_, i) => ({\n    id: i,\n    name: `Item ${i}`\n  })));\n\n  // useCallback - memoize function\n  const handleClick = useCallback(() => {\n    setCount(c => c + 1);\n  }, []); // Dependencies array\n\n  // useMemo - memoize expensive computation\n  const filteredItems = useMemo(() => {\n    console.log('Filtering...');\n    return items.filter(item =>\n      item.name.toLowerCase().includes(filter.toLowerCase())\n    );\n  }, [items, filter]); // Recompute only when items or filter change\n\n  const total = useMemo(() => {\n    return filteredItems.length;\n  }, [filteredItems]);\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <input\n        value={filter}\n        onChange={e => setFilter(e.target.value)}\n        placeholder=\"Filter...\"\n      />\n      <p>Total: {total}</p>\n      <ChildComponent onClick={handleClick} />\n      <ItemList items={filteredItems} />\n    </div>\n  );\n}\n\n// memo prevents re-render if props haven't changed\nconst ChildComponent = memo(({ onClick }) => {\n  console.log('Child rendered');\n  return <button onClick={onClick}>Increment</button>;\n});"
  },
  {
    "id": 6,
    "category": "State Management",
    "level": "mid",
    "title": "Context API",
    "question": "Explain Context API and when to use it.",
    "correctAnswer": "Context provides way to pass data through component tree without prop drilling. Create with createContext, provide with Provider, consume with useContext. Use for global data like theme, auth, language. For complex state, consider Redux/Zustand.",
    "codeExample": "import { createContext, useContext, useState } from 'react';\n\n// Create context\nconst AuthContext = createContext(null);\n\n// Provider component\nexport function AuthProvider({ children }) {\n  const [user, setUser] = useState(null);\n  const [loading, setLoading] = useState(true);\n\n  const login = async (email, password) => {\n    setLoading(true);\n    const response = await fetch('/api/login', {\n      method: 'POST',\n      body: JSON.stringify({ email, password })\n    });\n    const data = await response.json();\n    setUser(data.user);\n    localStorage.setItem('token', data.token);\n    setLoading(false);\n  };\n\n  const logout = () => {\n    setUser(null);\n    localStorage.removeItem('token');\n  };\n\n  const value = {\n    user,\n    loading,\n    login,\n    logout,\n    isAuthenticated: !!user\n  };\n\n  return (\n    <AuthContext.Provider value={value}>\n      {children}\n    </AuthContext.Provider>\n  );\n}\n\n// Custom hook to use context\nexport function useAuth() {\n  const context = useContext(AuthContext);\n  if (!context) {\n    throw new Error('useAuth must be used within AuthProvider');\n  }\n  return context;\n}\n\n// App setup\nfunction App() {\n  return (\n    <AuthProvider>\n      <Router>\n        <Routes>\n          <Route path=\"/\" element={<Home />} />\n          <Route path=\"/profile\" element={<ProtectedRoute><Profile /></ProtectedRoute>} />\n        </Routes>\n      </Router>\n    </AuthProvider>\n  );\n}\n\n// Usage in components\nfunction Profile() {\n  const { user, logout } = useAuth();\n\n  return (\n    <div>\n      <h1>Welcome, {user.name}!</h1>\n      <button onClick={logout}>Logout</button>\n    </div>\n  );\n}\n\nfunction ProtectedRoute({ children }) {\n  const { isAuthenticated, loading } = useAuth();\n\n  if (loading) return <div>Loading...</div>;\n  if (!isAuthenticated) return <Navigate to=\"/login\" />;\n\n  return children;\n}"
  },
  {
    "id": 8,
    "category": "Routing",
    "level": "mid",
    "title": "React Router",
    "question": "How do you implement routing with React Router v6?",
    "correctAnswer": "React Router v6 uses Routes/Route components for declarative routing. Features: nested routes, useNavigate for navigation, useParams for URL params, useLocation for current location, protected routes with conditional rendering, lazy loading with Suspense.",
    "codeExample": "import { BrowserRouter, Routes, Route, Link, useParams, useNavigate, Navigate, Outlet } from 'react-router-dom';\nimport { lazy, Suspense } from 'react';\n\n// Lazy loading\nconst Dashboard = lazy(() => import('./pages/Dashboard'));\nconst Settings = lazy(() => import('./pages/Settings'));\n\nfunction App() {\n  return (\n    <BrowserRouter>\n      <nav>\n        <Link to=\"/\">Home</Link>\n        <Link to=\"/about\">About</Link>\n        <Link to=\"/users\">Users</Link>\n      </nav>\n\n      <Suspense fallback={<div>Loading...</div>}>\n        <Routes>\n          <Route path=\"/\" element={<Home />} />\n          <Route path=\"/about\" element={<About />} />\n\n          {/* Nested routes */}\n          <Route path=\"/users\" element={<UsersLayout />}>\n            <Route index element={<UsersList />} />\n            <Route path=\":userId\" element={<UserDetail />} />\n            <Route path=\"new\" element={<NewUser />} />\n          </Route>\n\n          {/* Protected routes */}\n          <Route element={<ProtectedRoute />}>\n            <Route path=\"/dashboard\" element={<Dashboard />} />\n            <Route path=\"/settings\" element={<Settings />} />\n          </Route>\n\n          {/* 404 */}\n          <Route path=\"*\" element={<NotFound />} />\n        </Routes>\n      </Suspense>\n    </BrowserRouter>\n  );\n}\n\n// Layout with nested routes\nfunction UsersLayout() {\n  return (\n    <div>\n      <h1>Users</h1>\n      <Outlet /> {/* Renders child routes */}\n    </div>\n  );\n}\n\n// Using useParams\nfunction UserDetail() {\n  const { userId } = useParams();\n  const navigate = useNavigate();\n\n  return (\n    <div>\n      <h2>User {userId}</h2>\n      <button onClick={() => navigate('/users')}>\n        Back to Users\n      </button>\n    </div>\n  );\n}\n\n// Protected route wrapper\nfunction ProtectedRoute() {\n  const { isAuthenticated } = useAuth();\n\n  if (!isAuthenticated) {\n    return <Navigate to=\"/login\" replace />;\n  }\n\n  return <Outlet />;\n}\n\n// Programmatic navigation\nfunction LoginForm() {\n  const navigate = useNavigate();\n\n  const handleSubmit = async (data) => {\n    await login(data);\n    navigate('/dashboard', { replace: true });\n  };\n\n  return <form onSubmit={handleSubmit}>...</form>;\n}"
  },
  {
    "id": 10,
    "category": "Testing",
    "level": "mid",
    "title": "Testing with Jest & RTL",
    "question": "How do you test React components with Jest and React Testing Library?",
    "correctAnswer": "React Testing Library focuses on testing user behavior, not implementation. Use render() to mount components, screen queries to find elements, fireEvent/userEvent for interactions, waitFor for async. Test what users see and do. Mock API calls, test edge cases.",
    "codeExample": "import { render, screen, fireEvent, waitFor } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport { rest } from 'msw';\nimport { setupServer } from 'msw/node';\nimport UserProfile from './UserProfile';\n\n// Setup MSW server for API mocking\nconst server = setupServer(\n  rest.get('/api/users/:id', (req, res, ctx) => {\n    return res(ctx.json({\n      id: '1',\n      name: 'John Doe',\n      email: 'john@example.com'\n    }));\n  })\n);\n\nbeforeAll(() => server.listen());\nafterEach(() => server.resetHandlers());\nafterAll(() => server.close());\n\ndescribe('UserProfile', () => {\n  it('renders user data after loading', async () => {\n    render(<UserProfile userId=\"1\" />);\n\n    // Check loading state\n    expect(screen.getByText(/loading/i)).toBeInTheDocument();\n\n    // Wait for data to load\n    await waitFor(() => {\n      expect(screen.getByText('John Doe')).toBeInTheDocument();\n    });\n\n    expect(screen.getByText('john@example.com')).toBeInTheDocument();\n  });\n\n  it('handles API error', async () => {\n    server.use(\n      rest.get('/api/users/:id', (req, res, ctx) => {\n        return res(ctx.status(500));\n      })\n    );\n\n    render(<UserProfile userId=\"1\" />);\n\n    await waitFor(() => {\n      expect(screen.getByText(/error/i)).toBeInTheDocument();\n    });\n  });\n});\n\n// Testing form interactions\ndescribe('LoginForm', () => {\n  it('submits form with valid data', async () => {\n    const mockSubmit = jest.fn();\n    render(<LoginForm onSubmit={mockSubmit} />);\n\n    // Using userEvent (recommended)\n    const user = userEvent.setup();\n    await user.type(screen.getByLabelText(/email/i), 'john@example.com');\n    await user.type(screen.getByLabelText(/password/i), 'password123');\n    await user.click(screen.getByRole('button', { name: /login/i }));\n\n    expect(mockSubmit).toHaveBeenCalledWith({\n      email: 'john@example.com',\n      password: 'password123'\n    });\n  });\n\n  it('shows validation errors', async () => {\n    render(<LoginForm onSubmit={() => {}} />);\n\n    fireEvent.click(screen.getByRole('button', { name: /login/i }));\n\n    await waitFor(() => {\n      expect(screen.getByText(/email is required/i)).toBeInTheDocument();\n      expect(screen.getByText(/password is required/i)).toBeInTheDocument();\n    });\n  });\n});\n\n// Testing with Context\nimport { AuthProvider } from './AuthContext';\n\nfunction renderWithAuth(ui, { user = null } = {}) {\n  return render(\n    <AuthProvider value={{ user }}>\n      {ui}\n    </AuthProvider>\n  );\n}\n\ndescribe('ProtectedComponent', () => {\n  it('renders for authenticated user', () => {\n    renderWithAuth(<ProtectedComponent />, {\n      user: { id: '1', name: 'John' }\n    });\n\n    expect(screen.getByText(/welcome/i)).toBeInTheDocument();\n  });\n\n  it('redirects when not authenticated', () => {\n    renderWithAuth(<ProtectedComponent />, { user: null });\n\n    expect(screen.queryByText(/welcome/i)).not.toBeInTheDocument();\n  });\n});\n\n// Testing custom hooks\nimport { renderHook, act } from '@testing-library/react';\nimport { useCounter } from './useCounter';\n\ndescribe('useCounter', () => {\n  it('increments counter', () => {\n    const { result } = renderHook(() => useCounter(0));\n\n    expect(result.current.count).toBe(0);\n\n    act(() => {\n      result.current.increment();\n    });\n\n    expect(result.current.count).toBe(1);\n  });\n});"
  },
  {
    "id": 11,
    "category": "TypeScript",
    "level": "mid",
    "title": "TypeScript with React",
    "question": "How do you use TypeScript with React components and hooks?",
    "correctAnswer": "TypeScript adds type safety to React. Type props with interfaces, use React.FC or explicit typing, type hooks (useState<Type>), events (React.ChangeEvent), refs (useRef<HTMLElement>). Benefits: catch errors early, better IDE support, self-documenting code.",
    "codeExample": "import { useState, useEffect, useRef, ChangeEvent, FormEvent } from 'react';\n\n// Props interface\ninterface UserProps {\n  id: string;\n  name: string;\n  email?: string;\n  onUpdate: (user: User) => void;\n  children: React.ReactNode;\n}\n\n// Type alias\ntype User = {\n  id: string;\n  name: string;\n  email: string;\n  age: number;\n};\n\n// Functional component with typed props\nfunction UserCard({ id, name, email, onUpdate, children }: UserProps) {\n  const [editing, setEditing] = useState<boolean>(false);\n  const [user, setUser] = useState<User | null>(null);\n  const inputRef = useRef<HTMLInputElement>(null);\n\n  useEffect(() => {\n    fetchUser(id).then(setUser);\n  }, [id]);\n\n  const handleChange = (e: ChangeEvent<HTMLInputElement>) => {\n    const { name, value } = e.target;\n    setUser(prev => prev ? { ...prev, [name]: value } : null);\n  };\n\n  const handleSubmit = (e: FormEvent<HTMLFormElement>) => {\n    e.preventDefault();\n    if (user) {\n      onUpdate(user);\n    }\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <input\n        ref={inputRef}\n        name=\"name\"\n        value={user?.name || ''}\n        onChange={handleChange}\n      />\n      {children}\n    </form>\n  );\n}\n\n// Generic component\ninterface ListProps<T> {\n  items: T[];\n  renderItem: (item: T) => React.ReactNode;\n  keyExtractor: (item: T) => string;\n}\n\nfunction List<T>({ items, renderItem, keyExtractor }: ListProps<T>) {\n  return (\n    <ul>\n      {items.map(item => (\n        <li key={keyExtractor(item)}>\n          {renderItem(item)}\n        </li>\n      ))}\n    </ul>\n  );\n}\n\n// Usage\n<List\n  items={users}\n  renderItem={user => <div>{user.name}</div>}\n  keyExtractor={user => user.id}\n/>\n\n// Custom hook with types\nfunction useFetch<T>(url: string) {\n  const [data, setData] = useState<T | null>(null);\n  const [loading, setLoading] = useState<boolean>(true);\n  const [error, setError] = useState<Error | null>(null);\n\n  useEffect(() => {\n    fetch(url)\n      .then(res => res.json())\n      .then((data: T) => {\n        setData(data);\n        setLoading(false);\n      })\n      .catch((err: Error) => {\n        setError(err);\n        setLoading(false);\n      });\n  }, [url]);\n\n  return { data, loading, error };\n}\n\n// Usage with type inference\nconst { data, loading } = useFetch<User[]>('/api/users');\n\n// Event handlers\ntype ButtonProps = {\n  onClick: (e: React.MouseEvent<HTMLButtonElement>) => void;\n};\n\n// Context with types\ninterface AuthContextType {\n  user: User | null;\n  login: (email: string, password: string) => Promise<void>;\n  logout: () => void;\n}\n\nconst AuthContext = createContext<AuthContextType | null>(null);\n\nfunction useAuth() {\n  const context = useContext(AuthContext);\n  if (!context) {\n    throw new Error('useAuth must be within AuthProvider');\n  }\n  return context;\n}"
  },
  {
    "id": 5,
    "category": "Hooks",
    "level": "senior",
    "title": "Custom Hooks",
    "question": "How do you create and use custom hooks?",
    "correctAnswer": "Custom hooks are functions starting with 'use' that encapsulate reusable stateful logic. They can use other hooks. Extract common logic (data fetching, form handling, etc.) into custom hooks for code reuse and cleaner components.",
    "codeExample": "import { useState, useEffect } from 'react';\n\n// Custom hook for data fetching\nfunction useFetch(url) {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    let cancelled = false;\n\n    async function fetchData() {\n      try {\n        const response = await fetch(url);\n        const json = await response.json();\n        if (!cancelled) {\n          setData(json);\n          setError(null);\n        }\n      } catch (err) {\n        if (!cancelled) {\n          setError(err);\n        }\n      } finally {\n        if (!cancelled) {\n          setLoading(false);\n        }\n      }\n    }\n\n    fetchData();\n    return () => { cancelled = true; };\n  }, [url]);\n\n  return { data, loading, error };\n}\n\n// Custom hook for form handling\nfunction useForm(initialValues) {\n  const [values, setValues] = useState(initialValues);\n  const [errors, setErrors] = useState({});\n\n  const handleChange = (e) => {\n    const { name, value } = e.target;\n    setValues(prev => ({ ...prev, [name]: value }));\n  };\n\n  const handleSubmit = (callback, validate) => (e) => {\n    e.preventDefault();\n    const validationErrors = validate ? validate(values) : {};\n    setErrors(validationErrors);\n\n    if (Object.keys(validationErrors).length === 0) {\n      callback(values);\n    }\n  };\n\n  const reset = () => {\n    setValues(initialValues);\n    setErrors({});\n  };\n\n  return {\n    values,\n    errors,\n    handleChange,\n    handleSubmit,\n    reset\n  };\n}\n\n// Usage\nfunction UserProfile({ userId }) {\n  const { data: user, loading, error } = useFetch(`/api/users/${userId}`);\n\n  if (loading) return <div>Loading...</div>;\n  if (error) return <div>Error!</div>;\n\n  return <div>{user.name}</div>;\n}\n\nfunction LoginForm() {\n  const { values, errors, handleChange, handleSubmit } = useForm({\n    email: '',\n    password: ''\n  });\n\n  const validate = (values) => {\n    const errors = {};\n    if (!values.email) errors.email = 'Required';\n    if (!values.password) errors.password = 'Required';\n    return errors;\n  };\n\n  const onSubmit = async (values) => {\n    await login(values);\n  };\n\n  return (\n    <form onSubmit={handleSubmit(onSubmit, validate)}>\n      <input\n        name=\"email\"\n        value={values.email}\n        onChange={handleChange}\n      />\n      {errors.email && <span>{errors.email}</span>}\n\n      <input\n        name=\"password\"\n        type=\"password\"\n        value={values.password}\n        onChange={handleChange}\n      />\n      {errors.password && <span>{errors.password}</span>}\n\n      <button type=\"submit\">Login</button>\n    </form>\n  );\n}"
  },
  {
    "id": 7,
    "category": "State Management",
    "level": "senior",
    "title": "Redux & Redux Toolkit",
    "question": "Explain Redux architecture and how Redux Toolkit simplifies it.",
    "correctAnswer": "Redux is predictable state container with single store, actions, reducers. Redux Toolkit (RTK) is official, opinionated toolset that simplifies Redux: configureStore, createSlice, createAsyncThunk. Includes Immer for immutable updates, Redux DevTools, middleware setup.",
    "codeExample": "// store.js\nimport { configureStore } from '@reduxjs/toolkit';\nimport usersReducer from './usersSlice';\n\nexport const store = configureStore({\n  reducer: {\n    users: usersReducer\n  }\n});\n\n// usersSlice.js\nimport { createSlice, createAsyncThunk } from '@reduxjs/toolkit';\n\n// Async thunk\nexport const fetchUsers = createAsyncThunk(\n  'users/fetchUsers',\n  async () => {\n    const response = await fetch('/api/users');\n    return response.json();\n  }\n);\n\nconst usersSlice = createSlice({\n  name: 'users',\n  initialState: {\n    items: [],\n    loading: false,\n    error: null\n  },\n  reducers: {\n    userAdded: (state, action) => {\n      state.items.push(action.payload);\n    },\n    userUpdated: (state, action) => {\n      const index = state.items.findIndex(u => u.id === action.payload.id);\n      if (index !== -1) {\n        state.items[index] = action.payload;\n      }\n    },\n    userDeleted: (state, action) => {\n      state.items = state.items.filter(u => u.id !== action.payload);\n    }\n  },\n  extraReducers: (builder) => {\n    builder\n      .addCase(fetchUsers.pending, (state) => {\n        state.loading = true;\n      })\n      .addCase(fetchUsers.fulfilled, (state, action) => {\n        state.loading = false;\n        state.items = action.payload;\n      })\n      .addCase(fetchUsers.rejected, (state, action) => {\n        state.loading = false;\n        state.error = action.error.message;\n      });\n  }\n});\n\nexport const { userAdded, userUpdated, userDeleted } = usersSlice.actions;\nexport default usersSlice.reducer;\n\n// Component usage\nimport { useSelector, useDispatch } from 'react-redux';\nimport { fetchUsers, userAdded } from './usersSlice';\n\nfunction UsersList() {\n  const dispatch = useDispatch();\n  const { items, loading, error } = useSelector(state => state.users);\n\n  useEffect(() => {\n    dispatch(fetchUsers());\n  }, [dispatch]);\n\n  const handleAdd = () => {\n    dispatch(userAdded({ id: Date.now(), name: 'New User' }));\n  };\n\n  if (loading) return <div>Loading...</div>;\n  if (error) return <div>Error: {error}</div>;\n\n  return (\n    <div>\n      <button onClick={handleAdd}>Add User</button>\n      {items.map(user => (\n        <div key={user.id}>{user.name}</div>\n      ))}\n    </div>\n  );\n}\n\n// App setup\nimport { Provider } from 'react-redux';\nimport { store } from './store';\n\nfunction App() {\n  return (\n    <Provider store={store}>\n      <UsersList />\n    </Provider>\n  );\n}"
  },
  {
    "id": 9,
    "category": "Performance",
    "level": "senior",
    "title": "Performance Optimization",
    "question": "What techniques do you use to optimize React performance?",
    "correctAnswer": "Use React.memo for component memoization, useMemo/useCallback for expensive operations, virtualization for long lists, code splitting with lazy/Suspense, avoid inline objects/functions in render, use keys properly, implement pagination, optimize images, use React DevTools Profiler.",
    "codeExample": "import { memo, lazy, Suspense, useState, useMemo, useCallback } from 'react';\nimport { FixedSizeList } from 'react-window';\n\n// 1. Component memoization\nconst ExpensiveComponent = memo(({ data, onUpdate }) => {\n  console.log('Rendering ExpensiveComponent');\n  return <div>{data.value}</div>;\n}, (prevProps, nextProps) => {\n  // Custom comparison\n  return prevProps.data.value === nextProps.data.value;\n});\n\n// 2. Code splitting\nconst HeavyComponent = lazy(() => import('./HeavyComponent'));\n\nfunction App() {\n  return (\n    <Suspense fallback={<Spinner />}>\n      <HeavyComponent />\n    </Suspense>\n  );\n}\n\n// 3. Virtualization for long lists\nfunction VirtualizedList({ items }) {\n  const Row = ({ index, style }) => (\n    <div style={style}>\n      {items[index].name}\n    </div>\n  );\n\n  return (\n    <FixedSizeList\n      height={600}\n      itemCount={items.length}\n      itemSize={50}\n      width=\"100%\"\n    >\n      {Row}\n    </FixedSizeList>\n  );\n}\n\n// 4. Avoid inline objects/functions\n// Bad\nfunction Bad() {\n  return <Child style={{ color: 'red' }} onClick={() => {}} />;\n}\n\n// Good\nconst style = { color: 'red' };\nfunction Good() {\n  const handleClick = useCallback(() => {}, []);\n  return <Child style={style} onClick={handleClick} />;\n}\n\n// 5. Proper key usage\n// Bad - using index as key\n{items.map((item, index) => <Item key={index} {...item} />)}\n\n// Good - using unique id\n{items.map(item => <Item key={item.id} {...item} />)}\n\n// 6. Pagination instead of loading all\nfunction PaginatedList() {\n  const [page, setPage] = useState(1);\n  const { data } = useFetch(`/api/items?page=${page}&limit=20`);\n\n  return (\n    <div>\n      {data?.items.map(item => <Item key={item.id} {...item} />)}\n      <button onClick={() => setPage(p => p + 1)}>Load More</button>\n    </div>\n  );\n}\n\n// 7. useMemo for expensive calculations\nfunction DataTable({ data, filter }) {\n  const filteredData = useMemo(() => {\n    console.log('Filtering...');\n    return data.filter(item => item.category === filter);\n  }, [data, filter]);\n\n  const stats = useMemo(() => {\n    console.log('Calculating stats...');\n    return {\n      total: filteredData.length,\n      sum: filteredData.reduce((acc, item) => acc + item.value, 0)\n    };\n  }, [filteredData]);\n\n  return <div>{/* render */}</div>;\n}\n\n// 8. Debounce expensive operations\nimport { useMemo } from 'react';\nimport debounce from 'lodash/debounce';\n\nfunction SearchComponent() {\n  const [query, setQuery] = useState('');\n\n  const debouncedSearch = useMemo(\n    () => debounce((value) => {\n      performSearch(value);\n    }, 300),\n    []\n  );\n\n  const handleChange = (e) => {\n    setQuery(e.target.value);\n    debouncedSearch(e.target.value);\n  };\n\n  return <input value={query} onChange={handleChange} />;\n}"
  },
  {
    "id": 12,
    "category": "Advanced Patterns",
    "level": "senior",
    "title": "Render Props & HOC",
    "question": "Explain render props and Higher-Order Components patterns.",
    "correctAnswer": "Render props: component with function prop that returns React element, enabling dynamic rendering and logic sharing. HOC: function that takes component and returns enhanced component, for cross-cutting concerns. Modern React favors hooks over these patterns, but they're still useful.",
    "codeExample": "// Render Props Pattern\ninterface MouseTrackerProps {\n  render: (position: { x: number; y: number }) => React.ReactNode;\n}\n\nfunction MouseTracker({ render }: MouseTrackerProps) {\n  const [position, setPosition] = useState({ x: 0, y: 0 });\n\n  useEffect(() => {\n    const handleMove = (e: MouseEvent) => {\n      setPosition({ x: e.clientX, y: e.clientY });\n    };\n\n    window.addEventListener('mousemove', handleMove);\n    return () => window.removeEventListener('mousemove', handleMove);\n  }, []);\n\n  return <>{render(position)}</>;\n}\n\n// Usage\n<MouseTracker\n  render={({ x, y }) => (\n    <div>Mouse at {x}, {y}</div>\n  )}\n/>\n\n// Higher-Order Component\nfunction withAuth<P extends object>(\n  Component: React.ComponentType<P>\n) {\n  return function AuthenticatedComponent(props: P) {\n    const { user, loading } = useAuth();\n\n    if (loading) return <div>Loading...</div>;\n    if (!user) return <Navigate to=\"/login\" />;\n\n    return <Component {...props} />;\n  };\n}\n\n// Usage\nconst ProtectedDashboard = withAuth(Dashboard);\n\n// HOC with additional props\ninterface WithLoadingProps {\n  loading: boolean;\n}\n\nfunction withLoading<P extends object>(\n  Component: React.ComponentType<P>\n) {\n  return function LoadingComponent(\n    props: P & WithLoadingProps\n  ) {\n    const { loading, ...rest } = props;\n\n    if (loading) {\n      return <Spinner />;\n    }\n\n    return <Component {...(rest as P)} />;\n  };\n}\n\n// Compound Components Pattern\ninterface TabsContextType {\n  activeTab: string;\n  setActiveTab: (tab: string) => void;\n}\n\nconst TabsContext = createContext<TabsContextType | null>(null);\n\nfunction Tabs({ children }: { children: React.ReactNode }) {\n  const [activeTab, setActiveTab] = useState('');\n\n  return (\n    <TabsContext.Provider value={{ activeTab, setActiveTab }}>\n      <div className=\"tabs\">{children}</div>\n    </TabsContext.Provider>\n  );\n}\n\nfunction TabList({ children }: { children: React.ReactNode }) {\n  return <div className=\"tab-list\">{children}</div>;\n}\n\nfunction Tab({ value, children }: { value: string; children: React.ReactNode }) {\n  const context = useContext(TabsContext);\n  if (!context) throw new Error('Tab must be within Tabs');\n\n  return (\n    <button\n      className={context.activeTab === value ? 'active' : ''}\n      onClick={() => context.setActiveTab(value)}\n    >\n      {children}\n    </button>\n  );\n}\n\nfunction TabPanel({ value, children }: { value: string; children: React.ReactNode }) {\n  const context = useContext(TabsContext);\n  if (!context) throw new Error('TabPanel must be within Tabs');\n\n  if (context.activeTab !== value) return null;\n  return <div>{children}</div>;\n}\n\n// Usage\n<Tabs>\n  <TabList>\n    <Tab value=\"tab1\">Tab 1</Tab>\n    <Tab value=\"tab2\">Tab 2</Tab>\n  </TabList>\n  <TabPanel value=\"tab1\">Content 1</TabPanel>\n  <TabPanel value=\"tab2\">Content 2</TabPanel>\n</Tabs>"
  }
];
