export const questions = [
  {
    "id": 1,
    "category": "Python Basics",
    "level": "junior",
    "title": "Lists vs Tuples",
    "question": "What is the difference between lists and tuples in Python?",
    "correctAnswer": "Lists are mutable (can be changed after creation) and use square brackets []. Tuples are immutable (cannot be changed) and use parentheses (). Lists have more methods and slightly slower performance. Tuples are used for fixed collections and can be dictionary keys.",
    "codeExample": "# List - mutable\nmy_list = [1, 2, 3]\nmy_list[0] = 10  # ✓ Works\nmy_list.append(4)  # ✓ Can modify\nprint(my_list)  # [10, 2, 3, 4]\n\n# Tuple - immutable\nmy_tuple = (1, 2, 3)\n# my_tuple[0] = 10  # ✗ TypeError: 'tuple' object does not support item assignment\n\n# Tuples can be dictionary keys\ncoordinates = {(0, 0): \"origin\", (1, 1): \"diagonal\"}\n\n# Memory comparison\nimport sys\nprint(sys.getsizeof([1, 2, 3]))  # 88 bytes\nprint(sys.getsizeof((1, 2, 3)))  # 72 bytes\n\n# Tuple unpacking\nx, y, z = (1, 2, 3)\nprint(x, y, z)  # 1 2 3",
    "image": ""
  },
  {
    "id": 2,
    "category": "Python Basics",
    "level": "junior",
    "title": "List Comprehensions",
    "question": "Explain list comprehensions and when to use them.",
    "correctAnswer": "List comprehensions provide a concise way to create lists. Syntax: [expression for item in iterable if condition]. They're more readable and faster than traditional loops for creating lists. Use for simple transformations; avoid for complex logic.",
    "codeExample": "# Traditional way\nsquares = []\nfor x in range(10):\n    squares.append(x**2)\n\n# List comprehension\nsquares = [x**2 for x in range(10)]\n\n# With condition\neven_squares = [x**2 for x in range(10) if x % 2 == 0]\n# [0, 4, 16, 36, 64]\n\n# Nested comprehension\nmatrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nflattened = [num for row in matrix for num in row]\n# [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n# Dict comprehension\nsquares_dict = {x: x**2 for x in range(5)}\n# {0: 0, 1: 1, 2: 4, 3: 9, 4: 16}\n\n# Set comprehension\nunique_lengths = {len(word) for word in ['hello', 'world', 'python']}\n# {5, 6}\n\n# Generator expression (memory efficient)\nsquares_gen = (x**2 for x in range(1000000))  # Doesn't create list immediately"
  },
  {
    "id": 19,
    "category": "Error Handling",
    "level": "junior",
    "title": "Exceptions & Try/Except",
    "question": "Explain exception handling in Python.",
    "correctAnswer": "Use try/except to handle exceptions. try block contains code that might raise exception. except catches specific exceptions. else runs if no exception. finally always runs (cleanup). Raise exceptions with raise. Create custom exceptions by inheriting from Exception. Use specific exceptions, not bare except.",
    "codeExample": "# Basic try/except\ntry:\n    result = 10 / 0\nexcept ZeroDivisionError:\n    print(\"Cannot divide by zero\")\n\n# Multiple exceptions\ntry:\n    value = int(input(\"Enter number: \"))\n    result = 10 / value\nexcept ValueError:\n    print(\"Invalid number\")\nexcept ZeroDivisionError:\n    print(\"Cannot divide by zero\")\n\n# Catch multiple exception types\ntry:\n    risky_operation()\nexcept (ValueError, TypeError) as e:\n    print(f\"Error occurred: {e}\")\n\n# else clause (runs if no exception)\ntry:\n    result = int(\"123\")\nexcept ValueError:\n    print(\"Invalid number\")\nelse:\n    print(f\"Success: {result}\")\n\n# finally clause (always runs)\ntry:\n    file = open('data.txt')\n    data = file.read()\nexcept FileNotFoundError:\n    print(\"File not found\")\nfinally:\n    if 'file' in locals():\n        file.close()\n\n# Complete structure\ntry:\n    # Code that might raise exception\n    result = risky_operation()\nexcept SpecificError as e:\n    # Handle specific error\n    handle_error(e)\nexcept Exception as e:\n    # Catch all other exceptions\n    log_error(e)\nelse:\n    # Runs if no exception\n    process_result(result)\nfinally:\n    # Always runs (cleanup)\n    cleanup()\n\n# Raising exceptions\ndef validate_age(age):\n    if age < 0:\n        raise ValueError(\"Age cannot be negative\")\n    if age > 150:\n        raise ValueError(\"Age too high\")\n    return age\n\n# Re-raising exceptions\ntry:\n    process_data()\nexcept Exception as e:\n    log_error(e)\n    raise  # Re-raise same exception\n\n# Custom exceptions\nclass InsufficientFundsError(Exception):\n    def __init__(self, balance, amount):\n        self.balance = balance\n        self.amount = amount\n        super().__init__(f\"Insufficient funds: balance={balance}, needed={amount}\")\n\nclass BankAccount:\n    def __init__(self, balance):\n        self.balance = balance\n\n    def withdraw(self, amount):\n        if amount > self.balance:\n            raise InsufficientFundsError(self.balance, amount)\n        self.balance -= amount\n\ntry:\n    account = BankAccount(100)\n    account.withdraw(150)\nexcept InsufficientFundsError as e:\n    print(f\"Error: {e}\")\n    print(f\"Balance: {e.balance}, Needed: {e.amount}\")\n\n# Exception hierarchy\ntry:\n    operation()\nexcept FileNotFoundError:\n    # Specific error\n    pass\nexcept IOError:\n    # More general (parent of FileNotFoundError)\n    pass\nexcept Exception:\n    # Catch all\n    pass\n\n# Context manager for cleanup\nclass Resource:\n    def __enter__(self):\n        print(\"Acquiring resource\")\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        print(\"Releasing resource\")\n        if exc_type is not None:\n            print(f\"Exception occurred: {exc_type}\")\n        return False  # Propagate exception\n\nwith Resource() as r:\n    # Use resource\n    pass\n\n# Asserting\ndef process_positive(n):\n    assert n > 0, \"Number must be positive\"\n    return n * 2\n\n# Exception chaining\ntry:\n    connect_to_database()\nexcept ConnectionError as e:\n    raise RuntimeError(\"Failed to initialize\") from e\n\n# Suppressing exceptions\nfrom contextlib import suppress\n\nwith suppress(FileNotFoundError):\n    os.remove('file.txt')\n\n# Getting traceback\nimport traceback\n\ntry:\n    1 / 0\nexcept Exception:\n    traceback.print_exc()\n\n# Exception groups (Python 3.11+)\ntry:\n    raise ExceptionGroup(\"multiple errors\", [\n        ValueError(\"bad value\"),\n        TypeError(\"bad type\")\n    ])\nexcept* ValueError as e:\n    print(f\"Caught ValueError: {e}\")\nexcept* TypeError as e:\n    print(f\"Caught TypeError: {e}\")"
  },
  {
    "id": 20,
    "category": "Package Management",
    "level": "junior",
    "title": "Pip & Virtual Environments",
    "question": "How do you manage Python packages and virtual environments?",
    "correctAnswer": "Use pip to install packages. Virtual environments (venv/virtualenv) isolate project dependencies. Create with 'python -m venv env', activate with source/activate script. requirements.txt lists dependencies. Use pip freeze to generate. Best practice: one venv per project, always use venv, include requirements.txt in repo.",
    "codeExample": "# Creating virtual environment\n# Python 3.3+\npython3 -m venv myenv\n\n# Older alternative\n# pip install virtualenv\n# virtualenv myenv\n\n# Activating virtual environment\n# On macOS/Linux:\nsource myenv/bin/activate\n\n# On Windows:\nmyenv\\Scripts\\activate\n\n# Check you're in venv\nwhich python  # Should show venv path\npython --version\n\n# Installing packages\npip install requests\npip install Django==4.2.0  # Specific version\npip install 'Django>=4.0,<5.0'  # Version range\n\n# Install from requirements.txt\npip install -r requirements.txt\n\n# Uninstall package\npip uninstall requests\n\n# List installed packages\npip list\n\n# Show package info\npip show requests\n\n# Generate requirements.txt\npip freeze > requirements.txt\n\n# requirements.txt example\n# requirements.txt\nrequests==2.31.0\nDjango==4.2.0\npytest>=7.0.0\nblack~=23.0  # Compatible version\n\n# Installing in development mode\npip install -e .  # Install from setup.py in editable mode\n\n# Upgrade package\npip install --upgrade requests\n\n# Install from git\npip install git+https://github.com/user/repo.git\n\n# Install from local directory\npip install /path/to/package\n\n# Deactivate virtual environment\ndeactivate\n\n# requirements.txt best practices\n# Base requirements\n# requirements.txt\n\n# Development requirements\n# requirements-dev.txt\n-r requirements.txt  # Include base requirements\npytest==7.4.0\nblack==23.7.0\nflake8==6.0.0\n\n# pyproject.toml (modern approach)\n# pyproject.toml\n[tool.poetry]\nname = \"myproject\"\nversion = \"0.1.0\"\ndescription = \"\"\nauthors = [\"Your Name <you@example.com>\"]\n\n[tool.poetry.dependencies]\npython = \"^3.9\"\nrequests = \"^2.31.0\"\nDjango = \"^4.2.0\"\n\n[tool.poetry.dev-dependencies]\npytest = \"^7.4.0\"\nblack = \"^23.7.0\"\n\n# Using Poetry\npoetry init  # Create pyproject.toml\npoetry add requests  # Add dependency\npoetry install  # Install all dependencies\npoetry shell  # Activate venv\n\n# Using pipenv\npipenv install requests  # Create Pipfile\npipenv install --dev pytest  # Dev dependency\npipenv shell  # Activate environment\npipenv lock  # Generate Pipfile.lock\n\n# Conda (alternative)\nconda create -n myenv python=3.9\nconda activate myenv\nconda install requests\nconda list\nconda deactivate\n\n# Check for outdated packages\npip list --outdated\n\n# Security check\npip install safety\nsafety check\n\n# Project structure with venv\nmyproject/\n├── venv/  # Don't commit to git\n├── src/\n│   └── myapp/\n├── tests/\n├── requirements.txt\n├── .gitignore  # Add venv/ here\n└── README.md\n\n# .gitignore for Python\nvenv/\nenv/\n*.pyc\n__pycache__/\n*.egg-info/\ndist/\nbuild/\n\n# Upgrading pip itself\npython -m pip install --upgrade pip\n\n# Installing from TestPyPI\npip install --index-url https://test.pypi.org/simple/ mypackage"
  },
  {
    "id": 3,
    "category": "Python Basics",
    "level": "mid",
    "title": "Decorators",
    "question": "What are decorators and how do they work?",
    "correctAnswer": "Decorators are functions that modify the behavior of other functions or classes. They use @decorator_name syntax. Decorators wrap a function, adding functionality before/after execution. Common uses: logging, timing, authentication, caching.",
    "codeExample": "# Simple decorator\ndef my_decorator(func):\n    def wrapper(*args, **kwargs):\n        print(\"Before function call\")\n        result = func(*args, **kwargs)\n        print(\"After function call\")\n        return result\n    return wrapper\n\n@my_decorator\ndef greet(name):\n    print(f\"Hello, {name}!\")\n\ngreet(\"Alice\")\n# Output:\n# Before function call\n# Hello, Alice!\n# After function call\n\n# Decorator with arguments\ndef repeat(times):\n    def decorator(func):\n        def wrapper(*args, **kwargs):\n            for _ in range(times):\n                result = func(*args, **kwargs)\n            return result\n        return wrapper\n    return decorator\n\n@repeat(times=3)\ndef say_hello():\n    print(\"Hello!\")\n\n# Using functools.wraps to preserve metadata\nfrom functools import wraps\n\ndef timer(func):\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        import time\n        start = time.time()\n        result = func(*args, **kwargs)\n        end = time.time()\n        print(f\"{func.__name__} took {end - start:.2f} seconds\")\n        return result\n    return wrapper\n\n@timer\ndef slow_function():\n    import time\n    time.sleep(1)\n    return \"Done\"\n\n# Class decorator\ndef singleton(cls):\n    instances = {}\n    def get_instance(*args, **kwargs):\n        if cls not in instances:\n            instances[cls] = cls(*args, **kwargs)\n        return instances[cls]\n    return get_instance\n\n@singleton\nclass Database:\n    pass"
  },
  {
    "id": 4,
    "category": "OOP",
    "level": "mid",
    "title": "Classes & Inheritance",
    "question": "Explain Python classes, inheritance, and super().",
    "correctAnswer": "Classes define objects with attributes and methods. Inheritance allows classes to inherit from parent classes. super() calls parent class methods. Python supports multiple inheritance with MRO (Method Resolution Order). Use __init__ for constructors, self for instance reference.",
    "codeExample": "# Basic class\nclass Animal:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\n    def speak(self):\n        return f\"{self.name} makes a sound\"\n\n    def __str__(self):\n        return f\"{self.name} ({self.age} years old)\"\n\n# Inheritance\nclass Dog(Animal):\n    def __init__(self, name, age, breed):\n        super().__init__(name, age)  # Call parent constructor\n        self.breed = breed\n\n    def speak(self):  # Override parent method\n        return f\"{self.name} barks!\"\n\n    def fetch(self):\n        return f\"{self.name} fetches the ball\"\n\ndog = Dog(\"Buddy\", 3, \"Golden Retriever\")\nprint(dog.speak())  # Buddy barks!\nprint(dog.fetch())  # Buddy fetches the ball\n\n# Multiple inheritance\nclass Flyer:\n    def fly(self):\n        return \"Flying high!\"\n\nclass Swimmer:\n    def swim(self):\n        return \"Swimming fast!\"\n\nclass Duck(Animal, Flyer, Swimmer):\n    def speak(self):\n        return f\"{self.name} quacks!\"\n\nduck = Duck(\"Donald\", 2)\nprint(duck.speak())  # Donald quacks!\nprint(duck.fly())    # Flying high!\nprint(duck.swim())   # Swimming fast!\n\n# MRO - Method Resolution Order\nprint(Duck.__mro__)\n\n# Class vs Instance variables\nclass Counter:\n    count = 0  # Class variable (shared)\n\n    def __init__(self):\n        self.instance_count = 0  # Instance variable\n        Counter.count += 1\n\n    def increment(self):\n        self.instance_count += 1"
  },
  {
    "id": 5,
    "category": "OOP",
    "level": "mid",
    "title": "Magic Methods",
    "question": "What are magic methods (dunder methods) and common use cases?",
    "correctAnswer": "Magic methods start and end with double underscores (__method__). They define how objects behave with operators and built-in functions. Common ones: __init__, __str__, __repr__, __len__, __add__, __eq__, __getitem__, __call__. They enable operator overloading and custom behavior.",
    "codeExample": "class Vector:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    # String representation\n    def __str__(self):\n        return f\"Vector({self.x}, {self.y})\"\n\n    def __repr__(self):\n        return f\"Vector(x={self.x}, y={self.y})\"\n\n    # Arithmetic operators\n    def __add__(self, other):\n        return Vector(self.x + other.x, self.y + other.y)\n\n    def __mul__(self, scalar):\n        return Vector(self.x * scalar, self.y * scalar)\n\n    # Comparison\n    def __eq__(self, other):\n        return self.x == other.x and self.y == other.y\n\n    def __lt__(self, other):\n        return (self.x**2 + self.y**2) < (other.x**2 + other.y**2)\n\n    # Length\n    def __len__(self):\n        return int((self.x**2 + self.y**2) ** 0.5)\n\n    # Boolean\n    def __bool__(self):\n        return self.x != 0 or self.y != 0\n\nv1 = Vector(1, 2)\nv2 = Vector(3, 4)\n\nprint(v1 + v2)      # Vector(4, 6)\nprint(v1 * 2)       # Vector(2, 4)\nprint(v1 == v2)     # False\nprint(len(v1))      # 2\n\n# Context manager\nclass FileHandler:\n    def __init__(self, filename, mode):\n        self.filename = filename\n        self.mode = mode\n        self.file = None\n\n    def __enter__(self):\n        self.file = open(self.filename, self.mode)\n        return self.file\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        if self.file:\n            self.file.close()\n\nwith FileHandler('test.txt', 'w') as f:\n    f.write('Hello, World!')\n\n# Callable objects\nclass Multiplier:\n    def __init__(self, factor):\n        self.factor = factor\n\n    def __call__(self, x):\n        return x * self.factor\n\ndouble = Multiplier(2)\nprint(double(5))  # 10\n\n# Container methods\nclass CustomList:\n    def __init__(self, items):\n        self.items = items\n\n    def __getitem__(self, index):\n        return self.items[index]\n\n    def __setitem__(self, index, value):\n        self.items[index] = value\n\n    def __len__(self):\n        return len(self.items)\n\n    def __iter__(self):\n        return iter(self.items)"
  },
  {
    "id": 6,
    "category": "Data Structures",
    "level": "mid",
    "title": "Dict Methods & Operations",
    "question": "Explain dictionary methods and best practices.",
    "correctAnswer": "Dictionaries are key-value mappings. Key methods: get(), keys(), values(), items(), pop(), update(), setdefault(). Use get() for safe access, dict.get(key, default). Dict comprehensions for creation. Python 3.7+ maintains insertion order. Dictionaries are fast (O(1) lookup).",
    "codeExample": "# Creating dictionaries\nperson = {'name': 'Alice', 'age': 30}\nperson2 = dict(name='Bob', age=25)\n\n# Safe access\nage = person.get('age', 0)  # 30\ncity = person.get('city', 'Unknown')  # 'Unknown'\n\n# Methods\nprint(person.keys())    # dict_keys(['name', 'age'])\nprint(person.values())  # dict_values(['Alice', 30])\nprint(person.items())   # dict_items([('name', 'Alice'), ('age', 30)])\n\n# Update\nperson.update({'city': 'NYC', 'age': 31})\n\n# Setdefault - get or set default\nperson.setdefault('hobbies', []).append('reading')\n\n# Pop\nage = person.pop('age')  # Remove and return\ncountry = person.pop('country', 'USA')  # With default\n\n# Dict comprehension\nsquares = {x: x**2 for x in range(5)}\n\n# Merge dicts (Python 3.9+)\ndict1 = {'a': 1, 'b': 2}\ndict2 = {'b': 3, 'c': 4}\nmerged = dict1 | dict2  # {'a': 1, 'b': 3, 'c': 4}\n\n# Default dict\nfrom collections import defaultdict\n\nword_count = defaultdict(int)\nfor word in ['apple', 'banana', 'apple']:\n    word_count[word] += 1\n\n# Counter\nfrom collections import Counter\n\nwords = ['apple', 'banana', 'apple', 'cherry', 'banana', 'apple']\ncounter = Counter(words)\nprint(counter.most_common(2))  # [('apple', 3), ('banana', 2)]\n\n# Ordered dict (maintains insertion order)\nfrom collections import OrderedDict\n\nordered = OrderedDict()\nordered['first'] = 1\nordered['second'] = 2\nordered['third'] = 3\n\n# Chain map (combine multiple dicts)\nfrom collections import ChainMap\n\ndefaults = {'color': 'red', 'user': 'guest'}\ncustom = {'user': 'admin'}\nconfig = ChainMap(custom, defaults)  # custom overrides defaults\nprint(config['user'])  # 'admin'\nprint(config['color'])  # 'red'"
  },
  {
    "id": 8,
    "category": "Django",
    "level": "mid",
    "title": "Django ORM",
    "question": "How does Django ORM work and what are common query patterns?",
    "correctAnswer": "Django ORM maps Python classes (models) to database tables. Provides high-level API for CRUD operations. QuerySets are lazy (not executed until evaluated). Key methods: filter(), exclude(), get(), all(), create(), update(), delete(). Use select_related/prefetch_related to avoid N+1 queries.",
    "codeExample": "# models.py\nfrom django.db import models\n\nclass Author(models.Model):\n    name = models.CharField(max_length=100)\n    email = models.EmailField(unique=True)\n    created_at = models.DateTimeField(auto_now_add=True)\n\n    def __str__(self):\n        return self.name\n\nclass Book(models.Model):\n    title = models.CharField(max_length=200)\n    author = models.ForeignKey(Author, on_delete=models.CASCADE, related_name='books')\n    published_date = models.DateField()\n    price = models.DecimalField(max_digits=6, decimal_places=2)\n    is_published = models.BooleanField(default=False)\n\n    class Meta:\n        ordering = ['-published_date']\n        indexes = [models.Index(fields=['title'])]\n\n    def __str__(self):\n        return self.title\n\n# Basic queries\nbooks = Book.objects.all()  # Get all books\nbook = Book.objects.get(id=1)  # Get single object\nbook = Book.objects.filter(is_published=True)  # Filter\n\n# Chaining filters\nrecent_books = Book.objects.filter(\n    is_published=True\n).filter(\n    price__lt=20\n).order_by('-published_date')\n\n# Q objects for complex queries\nfrom django.db.models import Q\n\nbooks = Book.objects.filter(\n    Q(title__icontains='python') | Q(title__icontains='django')\n)\n\n# Aggregation\nfrom django.db.models import Count, Avg, Max, Min, Sum\n\nstats = Book.objects.aggregate(\n    total=Count('id'),\n    avg_price=Avg('price'),\n    max_price=Max('price')\n)\n\n# Annotate\nauthors = Author.objects.annotate(\n    book_count=Count('books')\n).filter(book_count__gt=3)\n\n# select_related (for ForeignKey - single query with JOIN)\nbooks = Book.objects.select_related('author').all()\nfor book in books:\n    print(book.author.name)  # No additional query\n\n# prefetch_related (for ManyToMany/reverse FK - separate queries)\nauthors = Author.objects.prefetch_related('books').all()\nfor author in authors:\n    print(author.books.all())  # No N+1 problem\n\n# Create\nbook = Book.objects.create(\n    title='Learning Django',\n    author=author,\n    published_date='2024-01-01',\n    price=29.99\n)\n\n# Update\nBook.objects.filter(id=1).update(price=19.99)\nbook.price = 19.99\nbook.save()\n\n# Delete\nBook.objects.filter(id=1).delete()\nbook.delete()\n\n# Raw SQL (when needed)\nbooks = Book.objects.raw('SELECT * FROM books WHERE price < %s', [20])\n\n# F expressions for database operations\nfrom django.db.models import F\n\nBook.objects.update(price=F('price') * 1.1)  # 10% increase\n\n# Exists\nif Book.objects.filter(title='Python Guide').exists():\n    print('Book exists')\n\n# Values and values_list\ntitles = Book.objects.values_list('title', flat=True)\nbook_data = Book.objects.values('title', 'price')"
  },
  {
    "id": 9,
    "category": "Django",
    "level": "mid",
    "title": "Django Views & URLs",
    "question": "Explain Django views, URL routing, and class-based views.",
    "correctAnswer": "Views handle HTTP requests and return responses. Function-based views (FBV) are simple functions. Class-based views (CBV) provide reusable patterns. URLconf maps URLs to views using path() or re_path(). CBVs offer generic views (ListView, DetailView, CreateView, etc.) for common patterns.",
    "codeExample": "# urls.py\nfrom django.urls import path, include\nfrom . import views\n\nurlpatterns = [\n    # Function-based views\n    path('', views.home, name='home'),\n    path('books/', views.book_list, name='book-list'),\n    path('books/<int:pk>/', views.book_detail, name='book-detail'),\n\n    # Class-based views\n    path('authors/', views.AuthorListView.as_view(), name='author-list'),\n    path('authors/<int:pk>/', views.AuthorDetailView.as_view(), name='author-detail'),\n\n    # URL patterns with regex\n    path('books/<slug:slug>/', views.book_by_slug, name='book-slug'),\n]\n\n# views.py - Function-based views\nfrom django.shortcuts import render, get_object_or_404, redirect\nfrom django.http import HttpResponse, JsonResponse\nfrom .models import Book, Author\nfrom .forms import BookForm\n\ndef home(request):\n    return render(request, 'home.html', {\n        'title': 'Welcome'\n    })\n\ndef book_list(request):\n    books = Book.objects.filter(is_published=True)\n    return render(request, 'books/list.html', {\n        'books': books\n    })\n\ndef book_detail(request, pk):\n    book = get_object_or_404(Book, pk=pk)\n    return render(request, 'books/detail.html', {\n        'book': book\n    })\n\ndef create_book(request):\n    if request.method == 'POST':\n        form = BookForm(request.POST)\n        if form.is_valid():\n            book = form.save()\n            return redirect('book-detail', pk=book.pk)\n    else:\n        form = BookForm()\n    return render(request, 'books/form.html', {'form': form})\n\n# Class-based views\nfrom django.views import View\nfrom django.views.generic import ListView, DetailView, CreateView, UpdateView, DeleteView\nfrom django.urls import reverse_lazy\n\n# Generic ListView\nclass AuthorListView(ListView):\n    model = Author\n    template_name = 'authors/list.html'\n    context_object_name = 'authors'\n    paginate_by = 10\n\n    def get_queryset(self):\n        return Author.objects.annotate(\n            book_count=Count('books')\n        ).filter(book_count__gt=0)\n\n    def get_context_data(self, **kwargs):\n        context = super().get_context_data(**kwargs)\n        context['total_authors'] = Author.objects.count()\n        return context\n\n# Generic DetailView\nclass AuthorDetailView(DetailView):\n    model = Author\n    template_name = 'authors/detail.html'\n    context_object_name = 'author'\n\n# Generic CreateView\nclass BookCreateView(CreateView):\n    model = Book\n    form_class = BookForm\n    template_name = 'books/form.html'\n    success_url = reverse_lazy('book-list')\n\n    def form_valid(self, form):\n        form.instance.created_by = self.request.user\n        return super().form_valid(form)\n\n# Generic UpdateView\nclass BookUpdateView(UpdateView):\n    model = Book\n    fields = ['title', 'price', 'is_published']\n    template_name = 'books/form.html'\n\n    def get_success_url(self):\n        return reverse_lazy('book-detail', kwargs={'pk': self.object.pk})\n\n# Generic DeleteView\nclass BookDeleteView(DeleteView):\n    model = Book\n    template_name = 'books/confirm_delete.html'\n    success_url = reverse_lazy('book-list')\n\n# Custom View class\nclass BookAPIView(View):\n    def get(self, request, pk):\n        book = get_object_or_404(Book, pk=pk)\n        return JsonResponse({\n            'id': book.id,\n            'title': book.title,\n            'author': book.author.name,\n            'price': float(book.price)\n        })\n\n    def post(self, request, pk):\n        # Handle POST request\n        pass\n\n# Mixins for reusable behavior\nfrom django.contrib.auth.mixins import LoginRequiredMixin, UserPassesTestMixin\n\nclass BookOwnerMixin(UserPassesTestMixin):\n    def test_func(self):\n        book = self.get_object()\n        return self.request.user == book.author.user\n\nclass ProtectedBookUpdateView(LoginRequiredMixin, BookOwnerMixin, UpdateView):\n    model = Book\n    fields = ['title', 'price']\n    template_name = 'books/form.html'"
  },
  {
    "id": 10,
    "category": "Flask",
    "level": "mid",
    "title": "Flask Basics & Routing",
    "question": "How do you build web applications with Flask?",
    "correctAnswer": "Flask is a lightweight WSGI web framework. Use @app.route() for routing, request object for HTTP data, render_template() for templates, jsonify() for JSON responses. Blueprints organize large apps. Flask-SQLAlchemy for ORM, Flask-Login for authentication. Simple, flexible, and extensible.",
    "codeExample": "from flask import Flask, request, render_template, jsonify, redirect, url_for\nfrom flask_sqlalchemy import SQLAlchemy\nfrom werkzeug.security import generate_password_hash, check_password_hash\n\napp = Flask(__name__)\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///app.db'\napp.config['SECRET_KEY'] = 'your-secret-key'\n\ndb = SQLAlchemy(app)\n\n# Models\nclass User(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    username = db.Column(db.String(80), unique=True, nullable=False)\n    email = db.Column(db.String(120), unique=True, nullable=False)\n    password_hash = db.Column(db.String(128))\n    posts = db.relationship('Post', backref='author', lazy=True)\n\n    def set_password(self, password):\n        self.password_hash = generate_password_hash(password)\n\n    def check_password(self, password):\n        return check_password_hash(self.password_hash, password)\n\nclass Post(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    title = db.Column(db.String(200), nullable=False)\n    content = db.Column(db.Text, nullable=False)\n    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)\n\n# Routes\n@app.route('/')\ndef home():\n    return render_template('index.html', title='Home')\n\n@app.route('/about')\ndef about():\n    return render_template('about.html')\n\n# Dynamic routes\n@app.route('/user/<username>')\ndef user_profile(username):\n    user = User.query.filter_by(username=username).first_or_404()\n    return render_template('profile.html', user=user)\n\n@app.route('/post/<int:post_id>')\ndef post_detail(post_id):\n    post = Post.query.get_or_404(post_id)\n    return render_template('post.html', post=post)\n\n# HTTP methods\n@app.route('/login', methods=['GET', 'POST'])\ndef login():\n    if request.method == 'POST':\n        username = request.form.get('username')\n        password = request.form.get('password')\n\n        user = User.query.filter_by(username=username).first()\n        if user and user.check_password(password):\n            # Login user\n            return redirect(url_for('home'))\n        else:\n            return render_template('login.html', error='Invalid credentials')\n\n    return render_template('login.html')\n\n# JSON API\n@app.route('/api/users')\ndef api_users():\n    users = User.query.all()\n    return jsonify([\n        {'id': u.id, 'username': u.username, 'email': u.email}\n        for u in users\n    ])\n\n@app.route('/api/posts', methods=['POST'])\ndef create_post():\n    data = request.get_json()\n    post = Post(\n        title=data['title'],\n        content=data['content'],\n        user_id=data['user_id']\n    )\n    db.session.add(post)\n    db.session.commit()\n    return jsonify({'id': post.id}), 201\n\n# Error handlers\n@app.errorhandler(404)\ndef not_found(error):\n    return render_template('404.html'), 404\n\n@app.errorhandler(500)\ndef internal_error(error):\n    db.session.rollback()\n    return render_template('500.html'), 500\n\n# Before/After request\n@app.before_request\ndef before_request():\n    # Runs before each request\n    pass\n\n@app.after_request\ndef after_request(response):\n    # Runs after each request\n    return response\n\n# Blueprints for organization\nfrom flask import Blueprint\n\napi = Blueprint('api', __name__, url_prefix='/api/v1')\n\n@api.route('/users')\ndef get_users():\n    users = User.query.all()\n    return jsonify([u.username for u in users])\n\napp.register_blueprint(api)\n\n# Context processors\n@app.context_processor\ndef inject_user():\n    return {'current_year': 2024}\n\nif __name__ == '__main__':\n    with app.app_context():\n        db.create_all()\n    app.run(debug=True)"
  },
  {
    "id": 12,
    "category": "Testing",
    "level": "mid",
    "title": "Unit Testing with pytest",
    "question": "How do you write and organize tests using pytest?",
    "correctAnswer": "Pytest is a popular testing framework. Write test functions starting with test_. Use fixtures for setup/teardown. Assert with simple assert statements. Pytest discovers tests automatically. Use parametrize for multiple test cases, monkeypatch for mocking, and markers for organization.",
    "codeExample": "# test_calculator.py\nimport pytest\n\n# Simple test\ndef test_addition():\n    assert 2 + 2 == 4\n\ndef test_subtraction():\n    assert 5 - 3 == 2\n\n# Fixtures for setup/teardown\n@pytest.fixture\ndef sample_data():\n    return [1, 2, 3, 4, 5]\n\n@pytest.fixture\ndef database():\n    # Setup\n    db = Database()\n    db.connect()\n    yield db  # Provide to test\n    # Teardown\n    db.disconnect()\n\ndef test_with_fixture(sample_data):\n    assert len(sample_data) == 5\n    assert sum(sample_data) == 15\n\n# Parametrize for multiple test cases\n@pytest.mark.parametrize(\"input,expected\", [\n    (2, 4),\n    (3, 9),\n    (4, 16),\n    (5, 25),\n])\ndef test_square(input, expected):\n    assert input ** 2 == expected\n\n# Test exceptions\ndef test_division_by_zero():\n    with pytest.raises(ZeroDivisionError):\n        1 / 0\n\ndef test_value_error():\n    with pytest.raises(ValueError, match=\"invalid literal\"):\n        int(\"not a number\")\n\n# Mocking with monkeypatch\ndef get_user_from_api(user_id):\n    # External API call\n    import requests\n    response = requests.get(f'https://api.example.com/users/{user_id}')\n    return response.json()\n\ndef test_get_user(monkeypatch):\n    def mock_get(*args, **kwargs):\n        class MockResponse:\n            def json(self):\n                return {'id': 1, 'name': 'Test User'}\n        return MockResponse()\n\n    monkeypatch.setattr('requests.get', mock_get)\n    user = get_user_from_api(1)\n    assert user['name'] == 'Test User'\n\n# Markers\n@pytest.mark.slow\ndef test_slow_operation():\n    import time\n    time.sleep(2)\n    assert True\n\n@pytest.mark.skip(reason=\"Not implemented yet\")\ndef test_future_feature():\n    pass\n\n@pytest.mark.skipif(sys.version_info < (3, 8), reason=\"Requires Python 3.8+\")\ndef test_new_feature():\n    pass\n\n@pytest.mark.xfail(reason=\"Known bug\")\ndef test_known_issue():\n    assert 1 == 2\n\n# Fixture scopes\n@pytest.fixture(scope=\"session\")\ndef db_connection():\n    # Setup once for entire test session\n    conn = create_connection()\n    yield conn\n    conn.close()\n\n@pytest.fixture(scope=\"module\")\ndef api_client():\n    # Setup once per module\n    client = APIClient()\n    yield client\n    client.cleanup()\n\n@pytest.fixture(scope=\"function\")  # Default\ndef temp_file():\n    # Setup for each test function\n    f = open('temp.txt', 'w')\n    yield f\n    f.close()\n    os.remove('temp.txt')\n\n# Conftest.py for shared fixtures\n# conftest.py\nimport pytest\n\n@pytest.fixture\ndef user():\n    return {'id': 1, 'name': 'Alice', 'email': 'alice@example.com'}\n\n# Class-based tests\nclass TestCalculator:\n    def test_add(self):\n        assert Calculator().add(2, 3) == 5\n\n    def test_subtract(self):\n        assert Calculator().subtract(5, 3) == 2\n\n    @pytest.fixture(autouse=True)\n    def setup_method(self):\n        # Runs before each test method\n        self.calc = Calculator()\n\n# Running tests\n# pytest                    # Run all tests\n# pytest test_file.py       # Run specific file\n# pytest -k \"test_add\"      # Run tests matching pattern\n# pytest -m slow            # Run tests with marker\n# pytest -v                 # Verbose output\n# pytest --cov=myapp        # Coverage report\n# pytest -x                 # Stop on first failure\n# pytest --pdb              # Drop into debugger on failure"
  },
  {
    "id": 17,
    "category": "Context Managers",
    "level": "mid",
    "title": "Context Managers",
    "question": "Explain context managers and how to create them.",
    "correctAnswer": "Context managers handle resource management with 'with' statement. Implement __enter__ and __exit__ methods. __enter__ sets up, returns resource. __exit__ cleans up, handles exceptions. Use contextlib.contextmanager decorator for simpler creation. Common for files, locks, database connections, temporary state changes.",
    "codeExample": "# Using built-in context manager\nwith open('file.txt', 'r') as f:\n    data = f.read()\n# File automatically closed\n\n# Class-based context manager\nclass FileManager:\n    def __init__(self, filename, mode):\n        self.filename = filename\n        self.mode = mode\n        self.file = None\n\n    def __enter__(self):\n        print(f\"Opening {self.filename}\")\n        self.file = open(self.filename, self.mode)\n        return self.file\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        print(f\"Closing {self.filename}\")\n        if self.file:\n            self.file.close()\n\n        # Return True to suppress exception, False to propagate\n        if exc_type is not None:\n            print(f\"Exception occurred: {exc_type.__name__}: {exc_val}\")\n\n        return False  # Don't suppress exceptions\n\nwith FileManager('test.txt', 'w') as f:\n    f.write('Hello, World!')\n\n# Using contextlib.contextmanager\nfrom contextlib import contextmanager\n\n@contextmanager\ndef file_manager(filename, mode):\n    print(f\"Opening {filename}\")\n    f = open(filename, mode)\n    try:\n        yield f\n    finally:\n        print(f\"Closing {filename}\")\n        f.close()\n\nwith file_manager('test.txt', 'r') as f:\n    data = f.read()\n\n# Database transaction context manager\nclass DatabaseTransaction:\n    def __init__(self, connection):\n        self.connection = connection\n\n    def __enter__(self):\n        self.connection.begin()\n        return self.connection\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        if exc_type is None:\n            self.connection.commit()\n        else:\n            self.connection.rollback()\n        return False\n\nwith DatabaseTransaction(db_conn) as conn:\n    conn.execute(\"INSERT INTO users ...\")\n    conn.execute(\"UPDATE accounts ...\")\n# Auto-commits if no exception, rolls back on error\n\n# Temporary directory\nimport tempfile\nimport shutil\n\n@contextmanager\ndef temporary_directory():\n    temp_dir = tempfile.mkdtemp()\n    try:\n        yield temp_dir\n    finally:\n        shutil.rmtree(temp_dir)\n\nwith temporary_directory() as temp_dir:\n    # Work with temporary directory\n    with open(f\"{temp_dir}/file.txt\", 'w') as f:\n        f.write('temporary data')\n# Directory automatically deleted\n\n# Timing context manager\nimport time\n\n@contextmanager\ndef timer(label):\n    start = time.time()\n    try:\n        yield\n    finally:\n        end = time.time()\n        print(f\"{label}: {end - start:.4f} seconds\")\n\nwith timer(\"Operation\"):\n    # Your code here\n    time.sleep(1)\n\n# Suppress exceptions\nfrom contextlib import suppress\n\nwith suppress(FileNotFoundError):\n    os.remove('non_existent_file.txt')\n# No error raised\n\n# Redirect stdout\nfrom contextlib import redirect_stdout\nimport io\n\nf = io.StringIO()\nwith redirect_stdout(f):\n    print('Hello, World!')\n    print('This goes to StringIO')\n\noutput = f.getvalue()\nprint(output)  # 'Hello, World!\nThis goes to StringIO\n'\n\n# Change directory\n@contextmanager\ndef change_dir(path):\n    old_dir = os.getcwd()\n    os.chdir(path)\n    try:\n        yield\n    finally:\n        os.chdir(old_dir)\n\nwith change_dir('/tmp'):\n    print(os.getcwd())  # /tmp\nprint(os.getcwd())  # Back to original\n\n# Lock context manager\nimport threading\n\nlock = threading.Lock()\n\nwith lock:\n    # Critical section\n    shared_resource.modify()\n# Lock automatically released\n\n# Multiple context managers\nwith open('input.txt') as infile, open('output.txt', 'w') as outfile:\n    data = infile.read()\n    outfile.write(data.upper())\n\n# ExitStack for dynamic context managers\nfrom contextlib import ExitStack\n\ndef process_files(filenames):\n    with ExitStack() as stack:\n        files = [stack.enter_context(open(fname)) for fname in filenames]\n        # All files open here\n        for f in files:\n            process(f.read())\n    # All files automatically closed\n\n# Async context manager\nclass AsyncDatabaseTransaction:\n    async def __aenter__(self):\n        await self.connection.begin()\n        return self.connection\n\n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        if exc_type is None:\n            await self.connection.commit()\n        else:\n            await self.connection.rollback()\n        return False\n\nasync with AsyncDatabaseTransaction(conn) as db:\n    await db.execute(\"INSERT ...\")"
  },
  {
    "id": 18,
    "category": "Type Hints",
    "level": "mid",
    "title": "Type Hints & MyPy",
    "question": "Explain Python type hints and how to use them effectively.",
    "correctAnswer": "Type hints are annotations that specify expected types. Not enforced at runtime but checked by tools like mypy. Use typing module for complex types (List, Dict, Optional, Union, Callable). Benefits: better IDE support, catch bugs early, self-documenting code. Python remains dynamically typed.",
    "codeExample": "from typing import List, Dict, Tuple, Optional, Union, Callable, Any\nfrom typing import TypeVar, Generic, Protocol\n\n# Basic type hints\ndef greet(name: str) -> str:\n    return f\"Hello, {name}!\"\n\ndef add(a: int, b: int) -> int:\n    return a + b\n\n# Collections\ndef process_items(items: List[str]) -> Dict[str, int]:\n    return {item: len(item) for item in items}\n\ndef get_coordinates() -> Tuple[float, float]:\n    return (40.7128, -74.0060)\n\n# Optional (can be None)\ndef find_user(user_id: int) -> Optional[User]:\n    user = database.get(user_id)\n    return user if user else None\n\n# Union (multiple types)\ndef process_id(id: Union[int, str]) -> str:\n    return str(id)\n\n# Callable\ndef apply_function(func: Callable[[int, int], int], x: int, y: int) -> int:\n    return func(x, y)\n\ndef add(a: int, b: int) -> int:\n    return a + b\n\nresult = apply_function(add, 5, 3)\n\n# Any (any type)\ndef process_data(data: Any) -> None:\n    print(data)\n\n# Type aliases\nUserId = int\nUserDict = Dict[str, Any]\n\ndef get_user(user_id: UserId) -> UserDict:\n    return {'id': user_id, 'name': 'Alice'}\n\n# Generic types\nT = TypeVar('T')\n\ndef first(items: List[T]) -> Optional[T]:\n    return items[0] if items else None\n\ndef reverse(items: List[T]) -> List[T]:\n    return items[::-1]\n\n# Generic class\nclass Stack(Generic[T]):\n    def __init__(self) -> None:\n        self.items: List[T] = []\n\n    def push(self, item: T) -> None:\n        self.items.append(item)\n\n    def pop(self) -> T:\n        return self.items.pop()\n\nstack: Stack[int] = Stack()\nstack.push(1)\nstack.push(2)\n\n# Protocol (structural subtyping)\nclass Drawable(Protocol):\n    def draw(self) -> None:\n        ...\n\ndef render(obj: Drawable) -> None:\n    obj.draw()\n\nclass Circle:\n    def draw(self) -> None:\n        print(\"Drawing circle\")\n\nrender(Circle())  # Works without explicit inheritance\n\n# Literal types\nfrom typing import Literal\n\ndef set_mode(mode: Literal['read', 'write', 'append']) -> None:\n    print(f\"Mode: {mode}\")\n\nset_mode('read')   # OK\n# set_mode('delete')  # Type error\n\n# TypedDict\nfrom typing import TypedDict\n\nclass User(TypedDict):\n    name: str\n    age: int\n    email: str\n\ndef create_user(user: User) -> None:\n    print(user['name'])\n\nuser: User = {'name': 'Alice', 'age': 30, 'email': 'alice@example.com'}\n\n# Overload\nfrom typing import overload\n\n@overload\ndef process(x: int) -> int: ...\n\n@overload\ndef process(x: str) -> str: ...\n\ndef process(x: Union[int, str]) -> Union[int, str]:\n    if isinstance(x, int):\n        return x * 2\n    return x.upper()\n\n# Class with type hints\nclass User:\n    def __init__(self, name: str, age: int) -> None:\n        self.name: str = name\n        self.age: int = age\n        self.friends: List[User] = []\n\n    def add_friend(self, friend: 'User') -> None:  # Forward reference\n        self.friends.append(friend)\n\n    def get_info(self) -> Dict[str, Any]:\n        return {'name': self.name, 'age': self.age}\n\n# NewType (create distinct types)\nfrom typing import NewType\n\nUserId = NewType('UserId', int)\nuser_id = UserId(12345)\n\ndef get_user(user_id: UserId) -> User:\n    ...\n\n# Final (cannot be subclassed/overridden)\nfrom typing import Final\n\nMAX_SIZE: Final = 100\n\nclass Base:\n    def method(self) -> None:\n        pass\n\n# Type checking with mypy\n# mypy script.py\n\n# Ignoring type checking\ndef legacy_function(x):  # type: ignore\n    return x\n\n# Inline type comments (Python < 3.6)\ndef old_style(x, y):\n    # type: (int, int) -> int\n    return x + y\n\n# Variable annotations\nname: str = \"Alice\"\nage: int = 30\nis_active: bool = True\nscores: List[float] = [85.5, 90.0, 78.5]\n\n# Cast\nfrom typing import cast\n\ndef get_value() -> Any:\n    return \"123\"\n\nvalue: int = cast(int, get_value())  # Tell type checker it's int"
  },
  {
    "id": 7,
    "category": "Data Structures",
    "level": "senior",
    "title": "Generators & Iterators",
    "question": "Explain generators, iterators, and their benefits.",
    "correctAnswer": "Generators are functions that yield values lazily using yield keyword. They create iterators efficiently without storing all values in memory. Iterators implement __iter__() and __next__(). Benefits: memory efficiency, infinite sequences, pipeline processing. Use for large datasets or streams.",
    "codeExample": "# Generator function\ndef fibonacci():\n    a, b = 0, 1\n    while True:\n        yield a\n        a, b = b, a + b\n\n# Usage\nfib = fibonacci()\nprint(next(fib))  # 0\nprint(next(fib))  # 1\nprint(next(fib))  # 1\nprint(next(fib))  # 2\n\n# Take first 10\nfib_10 = [next(fibonacci()) for _ in range(10)]\n\n# Generator expression\nsquares = (x**2 for x in range(1000000))  # Memory efficient\nprint(sum(squares))\n\n# Custom iterator\nclass Countdown:\n    def __init__(self, start):\n        self.current = start\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        if self.current <= 0:\n            raise StopIteration\n        self.current -= 1\n        return self.current + 1\n\nfor num in Countdown(5):\n    print(num)  # 5, 4, 3, 2, 1\n\n# yield from (delegating)\ndef flatten(nested_list):\n    for item in nested_list:\n        if isinstance(item, list):\n            yield from flatten(item)\n        else:\n            yield item\n\nnested = [1, [2, 3, [4, 5]], 6]\nprint(list(flatten(nested)))  # [1, 2, 3, 4, 5, 6]\n\n# Send values to generator\ndef averager():\n    total = 0\n    count = 0\n    average = None\n    while True:\n        value = yield average\n        total += value\n        count += 1\n        average = total / count\n\navg = averager()\nnext(avg)  # Prime the generator\nprint(avg.send(10))  # 10.0\nprint(avg.send(20))  # 15.0\nprint(avg.send(30))  # 20.0\n\n# Pipeline processing\ndef read_file(filename):\n    with open(filename) as f:\n        for line in f:\n            yield line\n\ndef filter_lines(lines, keyword):\n    for line in lines:\n        if keyword in line:\n            yield line\n\ndef uppercase(lines):\n    for line in lines:\n        yield line.upper()\n\n# Chain generators\nlines = read_file('data.txt')\nfiltered = filter_lines(lines, 'error')\nupper = uppercase(filtered)\nfor line in upper:\n    print(line)\n\n# itertools for advanced iteration\nfrom itertools import islice, cycle, chain, groupby\n\n# Take first 5 from infinite sequence\nfib_5 = list(islice(fibonacci(), 5))\n\n# Cycle through items\ncolors = cycle(['red', 'green', 'blue'])\nprint([next(colors) for _ in range(7)])\n\n# Chain iterables\ncombined = chain([1, 2], [3, 4], [5, 6])\nprint(list(combined))  # [1, 2, 3, 4, 5, 6]"
  },
  {
    "id": 11,
    "category": "Async Python",
    "level": "senior",
    "title": "Asyncio & Async/Await",
    "question": "Explain asyncio, async/await, and concurrent programming in Python.",
    "correctAnswer": "Asyncio is Python's async I/O framework. async def defines coroutines, await suspends execution. Event loop schedules coroutines. Benefits: handle many I/O operations concurrently without threads. Use for I/O-bound tasks (network, files). Not for CPU-bound (use multiprocessing instead).",
    "codeExample": "import asyncio\nimport aiohttp\nimport time\n\n# Basic coroutine\nasync def greet(name):\n    print(f\"Hello, {name}!\")\n    await asyncio.sleep(1)\n    print(f\"Goodbye, {name}!\")\n\n# Run single coroutine\nasyncio.run(greet(\"Alice\"))\n\n# Multiple concurrent coroutines\nasync def fetch_data(url):\n    async with aiohttp.ClientSession() as session:\n        async with session.get(url) as response:\n            return await response.text()\n\nasync def main():\n    urls = [\n        'https://api.github.com/users/1',\n        'https://api.github.com/users/2',\n        'https://api.github.com/users/3',\n    ]\n\n    # Run concurrently\n    tasks = [fetch_data(url) for url in urls]\n    results = await asyncio.gather(*tasks)\n\n    return results\n\n# asyncio.gather vs asyncio.as_completed\nasync def fetch_all():\n    urls = ['url1', 'url2', 'url3']\n\n    # gather - wait for all, preserves order\n    results = await asyncio.gather(\n        fetch_data(urls[0]),\n        fetch_data(urls[1]),\n        fetch_data(urls[2])\n    )\n\n    # as_completed - process as they complete\n    tasks = [fetch_data(url) for url in urls]\n    for coro in asyncio.as_completed(tasks):\n        result = await coro\n        print(result)\n\n# Timeout\nasync def with_timeout():\n    try:\n        result = await asyncio.wait_for(\n            fetch_data('https://slow-api.com'),\n            timeout=5.0\n        )\n    except asyncio.TimeoutError:\n        print(\"Request timed out\")\n\n# Async context manager\nclass AsyncDatabase:\n    async def __aenter__(self):\n        self.conn = await self.connect()\n        return self.conn\n\n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        await self.conn.close()\n\n    async def connect(self):\n        await asyncio.sleep(1)\n        return \"DB Connection\"\n\nasync def use_db():\n    async with AsyncDatabase() as db:\n        print(db)\n\n# Async iterator\nclass AsyncRange:\n    def __init__(self, start, end):\n        self.current = start\n        self.end = end\n\n    def __aiter__(self):\n        return self\n\n    async def __anext__(self):\n        if self.current >= self.end:\n            raise StopAsyncIteration\n        await asyncio.sleep(0.1)\n        self.current += 1\n        return self.current - 1\n\nasync def iterate():\n    async for num in AsyncRange(0, 5):\n        print(num)\n\n# Semaphore for limiting concurrency\nasync def limited_concurrency():\n    sem = asyncio.Semaphore(3)  # Max 3 concurrent\n\n    async def worker(n):\n        async with sem:\n            print(f\"Worker {n} starting\")\n            await asyncio.sleep(1)\n            print(f\"Worker {n} done\")\n\n    await asyncio.gather(*[worker(i) for i in range(10)])\n\n# Event for synchronization\nasync def waiter(event):\n    print(\"Waiting for event...\")\n    await event.wait()\n    print(\"Event received!\")\n\nasync def setter(event):\n    await asyncio.sleep(2)\n    print(\"Setting event\")\n    event.set()\n\nasync def sync_example():\n    event = asyncio.Event()\n    await asyncio.gather(\n        waiter(event),\n        setter(event)\n    )\n\n# Queue for producer/consumer\nasync def producer(queue):\n    for i in range(5):\n        await asyncio.sleep(0.5)\n        await queue.put(i)\n        print(f\"Produced {i}\")\n\nasync def consumer(queue):\n    while True:\n        item = await queue.get()\n        print(f\"Consumed {item}\")\n        await asyncio.sleep(1)\n        queue.task_done()\n\nasync def queue_example():\n    queue = asyncio.Queue()\n    await asyncio.gather(\n        producer(queue),\n        consumer(queue)\n    )\n\n# Run with different methods\nasyncio.run(main())\n\n# Create event loop manually\nloop = asyncio.get_event_loop()\ntry:\n    result = loop.run_until_complete(main())\nfinally:\n    loop.close()"
  },
  {
    "id": 13,
    "category": "Testing",
    "level": "senior",
    "title": "Mocking & Patching",
    "question": "How do you use unittest.mock for testing?",
    "correctAnswer": "unittest.mock provides Mock and patch for replacing dependencies in tests. Mock objects record calls and can be configured to return specific values. patch temporarily replaces objects. Use for external dependencies (APIs, databases, file I/O). Verify calls with assert_called_with, assert_called_once, call_count.",
    "codeExample": "from unittest.mock import Mock, patch, MagicMock, call\nimport unittest\n\n# Basic Mock\ndef test_basic_mock():\n    mock = Mock()\n    mock.return_value = 42\n\n    result = mock()\n    assert result == 42\n    mock.assert_called_once()\n\n# Mock with side effects\ndef test_side_effects():\n    mock = Mock(side_effect=[1, 2, 3])\n    assert mock() == 1\n    assert mock() == 2\n    assert mock() == 3\n\n# Mock exceptions\ndef test_mock_exception():\n    mock = Mock(side_effect=ValueError(\"Invalid input\"))\n    with pytest.raises(ValueError):\n        mock()\n\n# Patch decorator\n@patch('module.external_api_call')\ndef test_with_patch(mock_api):\n    mock_api.return_value = {'status': 'success'}\n\n    result = my_function()\n\n    mock_api.assert_called_once()\n    assert result['status'] == 'success'\n\n# Patch context manager\ndef test_with_context_manager():\n    with patch('module.external_api_call') as mock_api:\n        mock_api.return_value = {'data': 'test'}\n        result = my_function()\n        assert result['data'] == 'test'\n\n# Multiple patches\n@patch('module.function_b')\n@patch('module.function_a')\ndef test_multiple_patches(mock_a, mock_b):\n    # Note: patches are applied bottom to top\n    mock_a.return_value = 1\n    mock_b.return_value = 2\n\n    result = combined_function()\n\n    mock_a.assert_called_once()\n    mock_b.assert_called_once()\n\n# Patch object method\nclass DataFetcher:\n    def fetch(self):\n        # External API call\n        pass\n\ndef test_patch_method():\n    fetcher = DataFetcher()\n    with patch.object(fetcher, 'fetch', return_value={'data': 'mocked'}):\n        result = fetcher.fetch()\n        assert result['data'] == 'mocked'\n\n# Mock attributes\ndef test_mock_attributes():\n    mock = Mock()\n    mock.method.return_value = 'result'\n    mock.attribute = 'value'\n\n    assert mock.method() == 'result'\n    assert mock.attribute == 'value'\n\n# Spec for type safety\ndef test_with_spec():\n    class RealClass:\n        def real_method(self):\n            pass\n\n    mock = Mock(spec=RealClass)\n    mock.real_method()  # OK\n    # mock.fake_method()  # AttributeError\n\n# MagicMock for magic methods\ndef test_magic_mock():\n    mock = MagicMock()\n    mock.__getitem__.return_value = 42\n\n    assert mock['key'] == 42\n    mock.__getitem__.assert_called_with('key')\n\n# Assert call arguments\ndef test_call_arguments():\n    mock = Mock()\n    mock(1, 2, key='value')\n\n    mock.assert_called_with(1, 2, key='value')\n    mock.assert_called_once_with(1, 2, key='value')\n\n# Check multiple calls\ndef test_multiple_calls():\n    mock = Mock()\n    mock(1)\n    mock(2)\n    mock(3)\n\n    assert mock.call_count == 3\n    mock.assert_has_calls([call(1), call(2), call(3)])\n\n# ANY matcher\nfrom unittest.mock import ANY\n\ndef test_any_matcher():\n    mock = Mock()\n    mock('test', 123)\n\n    mock.assert_called_with(ANY, 123)\n\n# PropertyMock\ndef test_property_mock():\n    with patch('module.MyClass.my_property', new_callable=PropertyMock) as mock_prop:\n        mock_prop.return_value = 'mocked_value'\n        obj = MyClass()\n        assert obj.my_property == 'mocked_value'\n\n# Async mock\nimport asyncio\n\nasync def async_function():\n    return await external_async_call()\n\n@pytest.mark.asyncio\nasync def test_async_mock():\n    with patch('module.external_async_call', new_callable=AsyncMock) as mock:\n        mock.return_value = 'async result'\n        result = await async_function()\n        assert result == 'async result'\n\n# Mocking datetime\nfrom datetime import datetime\n\ndef test_datetime_mock():\n    fixed_time = datetime(2024, 1, 1, 12, 0, 0)\n    with patch('module.datetime') as mock_datetime:\n        mock_datetime.now.return_value = fixed_time\n        result = function_using_datetime()\n        assert result.hour == 12\n\n# Reset mock\ndef test_reset_mock():\n    mock = Mock()\n    mock(1)\n    assert mock.call_count == 1\n\n    mock.reset_mock()\n    assert mock.call_count == 0"
  },
  {
    "id": 14,
    "category": "Performance",
    "level": "senior",
    "title": "Performance Optimization",
    "question": "What techniques do you use to optimize Python code performance?",
    "correctAnswer": "Profile first with cProfile/line_profiler to find bottlenecks. Use built-in functions (they're in C). List comprehensions faster than loops. Generators for memory efficiency. Cache repeated computations. Use appropriate data structures. NumPy for numerical operations. Avoid global variables. Consider multiprocessing for CPU-bound tasks.",
    "codeExample": "import time\nfrom functools import lru_cache\nimport cProfile\nimport pstats\n\n# 1. Profiling\ndef profile_function():\n    profiler = cProfile.Profile()\n    profiler.enable()\n\n    # Your code here\n    expensive_operation()\n\n    profiler.disable()\n    stats = pstats.Stats(profiler)\n    stats.sort_stats('cumulative')\n    stats.print_stats()\n\n# 2. Caching\n@lru_cache(maxsize=128)\ndef fibonacci(n):\n    if n < 2:\n        return n\n    return fibonacci(n-1) + fibonacci(n-2)\n\n# Without cache: O(2^n)\n# With cache: O(n)\n\n# 3. List comprehensions vs loops\n# Slow\nresult = []\nfor i in range(1000):\n    result.append(i**2)\n\n# Fast\nresult = [i**2 for i in range(1000)]\n\n# 4. Generators for memory\n# Memory intensive\ndef get_numbers():\n    return [i for i in range(1000000)]\n\n# Memory efficient\ndef get_numbers():\n    return (i for i in range(1000000)\n\n# 5. Use built-in functions\n# Slow\ntotal = 0\nfor i in range(1000):\n    total += i\n\n# Fast (built-in C implementation)\ntotal = sum(range(1000))\n\n# 6. Appropriate data structures\n# Slow: list membership test O(n)\nitems = [1, 2, 3, 4, 5]\nif 3 in items:\n    pass\n\n# Fast: set membership test O(1)\nitems = {1, 2, 3, 4, 5}\nif 3 in items:\n    pass\n\n# 7. String concatenation\n# Slow\nresult = \"\"\nfor i in range(1000):\n    result += str(i)\n\n# Fast\nresult = \"\".join(str(i) for i in range(1000))\n\n# 8. Local variables faster than globals\ndef fast():\n    local_var = some_value\n    for i in range(1000):\n        x = local_var  # Faster\n\n# 9. NumPy for numerical operations\nimport numpy as np\n\n# Slow Python loop\ndata = list(range(1000000))\nresult = [x**2 for x in data]\n\n# Fast NumPy\ndata = np.arange(1000000)\nresult = data**2\n\n# 10. Multiprocessing for CPU-bound\nfrom multiprocessing import Pool\n\ndef process_chunk(chunk):\n    return [x**2 for x in chunk]\n\ndef parallel_process(data):\n    with Pool() as pool:\n        chunks = np.array_split(data, 4)\n        results = pool.map(process_chunk, chunks)\n    return np.concatenate(results)\n\n# 11. Avoid repeated lookups\n# Slow\nfor i in range(1000):\n    value = my_dict['key']['nested']['value']\n\n# Fast\nnested_value = my_dict['key']['nested']['value']\nfor i in range(1000):\n    value = nested_value\n\n# 12. Use __slots__ for classes\nclass Regular:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\nclass Optimized:\n    __slots__ = ['x', 'y']\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n# Optimized uses less memory\n\n# 13. Timing decorator\ndef timing_decorator(func):\n    def wrapper(*args, **kwargs):\n        start = time.perf_counter()\n        result = func(*args, **kwargs)\n        end = time.perf_counter()\n        print(f\"{func.__name__} took {end - start:.4f} seconds\")\n        return result\n    return wrapper\n\n@timing_decorator\ndef slow_function():\n    time.sleep(1)\n\n# 14. Use itertools for efficient iteration\nfrom itertools import chain, islice, groupby\n\n# Instead of nested loops\ncombined = list(chain([1, 2], [3, 4], [5, 6]))\n\n# Take first n efficiently\nfirst_10 = list(islice(infinite_generator(), 10))\n\n# 15. Compile regex patterns\nimport re\n\n# Slow (compiles every time)\nfor text in texts:\n    re.search(r'd+', text)\n\n# Fast (compile once)\npattern = re.compile(r'd+')\nfor text in texts:\n    pattern.search(text)\n\n# 16. Context managers for resource management\nwith open('file.txt') as f:\n    data = f.read()\n# File automatically closed\n\n# 17. use map/filter with built-ins\n# Slow\nresult = [int(x) for x in string_list]\n\n# Fast (in C)\nresult = list(map(int, string_list))"
  },
  {
    "id": 15,
    "category": "Concurrency",
    "level": "senior",
    "title": "Threading vs Multiprocessing",
    "question": "Explain threading, multiprocessing, and when to use each.",
    "correctAnswer": "Threading uses multiple threads in one process, good for I/O-bound tasks (limited by GIL for CPU). Multiprocessing uses separate processes with separate memory, bypasses GIL, good for CPU-bound tasks. Threading shares memory (faster communication but race conditions). Multiprocessing isolated (slower IPC but no GIL).",
    "codeExample": "import threading\nimport multiprocessing\nimport time\nfrom concurrent.futures import ThreadPoolExecutor, ProcessPoolExecutor\n\n# 1. THREADING - I/O Bound Tasks\ndef download_file(url):\n    time.sleep(1)  # Simulates I/O\n    return f\"Downloaded {url}\"\n\n# Sequential (slow)\ndef sequential():\n    start = time.time()\n    for i in range(5):\n        download_file(f\"url_{i}\")\n    print(f\"Sequential: {time.time() - start:.2f}s\")\n\n# Threading (fast for I/O)\ndef with_threading():\n    start = time.time()\n    threads = []\n    for i in range(5):\n        thread = threading.Thread(target=download_file, args=(f\"url_{i}\",))\n        threads.append(thread)\n        thread.start()\n\n    for thread in threads:\n        thread.join()\n\n    print(f\"Threading: {time.time() - start:.2f}s\")\n\n# ThreadPoolExecutor (easier)\ndef with_threadpool():\n    start = time.time()\n    with ThreadPoolExecutor(max_workers=5) as executor:\n        urls = [f\"url_{i}\" for i in range(5)]\n        results = list(executor.map(download_file, urls))\n    print(f\"ThreadPool: {time.time() - start:.2f}s\")\n\n# 2. MULTIPROCESSING - CPU Bound Tasks\ndef cpu_intensive(n):\n    total = 0\n    for i in range(n):\n        total += i ** 2\n    return total\n\n# Sequential\ndef sequential_cpu():\n    start = time.time()\n    results = [cpu_intensive(10000000) for _ in range(4)]\n    print(f\"Sequential CPU: {time.time() - start:.2f}s\")\n\n# Multiprocessing (faster for CPU)\ndef with_multiprocessing():\n    start = time.time()\n    with ProcessPoolExecutor(max_workers=4) as executor:\n        results = list(executor.map(cpu_intensive, [10000000]*4))\n    print(f\"Multiprocessing: {time.time() - start:.2f}s\")\n\n# 3. Thread Safety - Locks\ncounter = 0\nlock = threading.Lock()\n\ndef increment():\n    global counter\n    for _ in range(100000):\n        with lock:  # Thread safe\n            counter += 1\n\nthreads = [threading.Thread(target=increment) for _ in range(10)]\nfor t in threads:\n    t.start()\nfor t in threads:\n    t.join()\n\nprint(f\"Counter: {counter}\")  # Should be 1000000\n\n# 4. Thread Communication - Queue\nfrom queue import Queue\n\ndef producer(queue):\n    for i in range(5):\n        time.sleep(0.5)\n        queue.put(i)\n        print(f\"Produced {i}\")\n\ndef consumer(queue):\n    while True:\n        item = queue.get()\n        if item is None:\n            break\n        print(f\"Consumed {item}\")\n        queue.task_done()\n\nqueue = Queue()\nprod_thread = threading.Thread(target=producer, args=(queue,))\ncons_thread = threading.Thread(target=consumer, args=(queue,))\n\nprod_thread.start()\ncons_thread.start()\n\nprod_thread.join()\nqueue.put(None)  # Signal to stop\ncons_thread.join()\n\n# 5. Process Communication - Pipe\ndef sender(conn):\n    for i in range(5):\n        conn.send(i)\n        time.sleep(0.5)\n    conn.close()\n\ndef receiver(conn):\n    while True:\n        try:\n            msg = conn.recv()\n            print(f\"Received: {msg}\")\n        except EOFError:\n            break\n\nparent_conn, child_conn = multiprocessing.Pipe()\np1 = multiprocessing.Process(target=sender, args=(child_conn,))\np2 = multiprocessing.Process(target=receiver, args=(parent_conn,))\n\np1.start()\np2.start()\np1.join()\np2.join()\n\n# 6. Shared Memory (Multiprocessing)\nfrom multiprocessing import Value, Array\n\ndef increment_shared(shared_value, shared_array):\n    shared_value.value += 1\n    for i in range(len(shared_array)):\n        shared_array[i] += 1\n\nshared_num = Value('i', 0)\nshared_arr = Array('i', [1, 2, 3, 4, 5])\n\nprocesses = [\n    multiprocessing.Process(target=increment_shared, args=(shared_num, shared_arr))\n    for _ in range(10)\n]\n\nfor p in processes:\n    p.start()\nfor p in processes:\n    p.join()\n\nprint(f\"Shared value: {shared_num.value}\")  # 10\nprint(f\"Shared array: {list(shared_arr)}\")  # [11, 12, 13, 14, 15]\n\n# 7. Threading Event for synchronization\nevent = threading.Event()\n\ndef waiter():\n    print(\"Waiting for event...\")\n    event.wait()\n    print(\"Event occurred!\")\n\ndef setter():\n    time.sleep(2)\n    print(\"Setting event\")\n    event.set()\n\nt1 = threading.Thread(target=waiter)\nt2 = threading.Thread(target=setter)\nt1.start()\nt2.start()\nt1.join()\nt2.join()\n\n# 8. Process Pool with map\ndef square(x):\n    return x ** 2\n\nwith multiprocessing.Pool(processes=4) as pool:\n    numbers = range(100)\n    results = pool.map(square, numbers)\n    print(f\"Results: {results[:10]}\")\n\n# 9. Thread local storage\nthread_local = threading.local()\n\ndef process_data():\n    thread_local.value = threading.current_thread().name\n    time.sleep(0.1)\n    print(f\"Thread {thread_local.value}\")\n\nthreads = [threading.Thread(target=process_data) for _ in range(5)]\nfor t in threads:\n    t.start()\nfor t in threads:\n    t.join()\n\n# WHEN TO USE:\n# Threading: I/O bound (network, file operations, databases)\n# Multiprocessing: CPU bound (calculations, data processing, image processing)\n# Asyncio: Many concurrent I/O operations (web scraping, APIs)"
  },
  {
    "id": 16,
    "category": "Advanced",
    "level": "senior",
    "title": "Metaclasses",
    "question": "What are metaclasses and when would you use them?",
    "correctAnswer": "Metaclasses create classes (classes are instances of metaclasses). type is the default metaclass. Override __new__ and __init__ to customize class creation. Use cases: ORM (Django models), API clients, validation frameworks, singleton patterns. Rare in application code - 'metaclasses are deeper magic than 99% of users should ever worry about' (Tim Peters).",
    "codeExample": "# type is a metaclass\nclass MyClass:\n    pass\n\nprint(type(MyClass))  # <class 'type'>\nprint(type(int))      # <class 'type'>\nprint(type(str))      # <class 'type'>\n\n# Creating class with type()\nMyDynamicClass = type('MyDynamicClass', (), {'x': 5})\nobj = MyDynamicClass()\nprint(obj.x)  # 5\n\n# Custom metaclass\nclass Meta(type):\n    def __new__(mcs, name, bases, attrs):\n        print(f\"Creating class {name}\")\n\n        # Add uppercase version of all methods\n        uppercase_attrs = {}\n        for attr_name, attr_value in attrs.items():\n            if not attr_name.startswith('__'):\n                uppercase_attrs[attr_name.upper()] = attr_value\n            uppercase_attrs[attr_name] = attr_value\n\n        return super().__new__(mcs, name, bases, uppercase_attrs)\n\n    def __init__(cls, name, bases, attrs):\n        print(f\"Initializing class {name}\")\n        super().__init__(name, bases, attrs)\n\nclass MyClass(metaclass=Meta):\n    def method(self):\n        return \"Hello\"\n\nobj = MyClass()\nprint(obj.method())   # Hello\nprint(obj.METHOD())   # Hello\n\n# Singleton metaclass\nclass Singleton(type):\n    _instances = {}\n\n    def __call__(cls, *args, **kwargs):\n        if cls not in cls._instances:\n            cls._instances[cls] = super().__call__(*args, **kwargs)\n        return cls._instances[cls]\n\nclass Database(metaclass=Singleton):\n    def __init__(self):\n        print(\"Connecting to database...\")\n\ndb1 = Database()  # Connects\ndb2 = Database()  # Returns same instance\nprint(db1 is db2)  # True\n\n# ORM-style metaclass\nclass ModelMeta(type):\n    def __new__(mcs, name, bases, attrs):\n        # Skip base Model class\n        if name == 'Model':\n            return super().__new__(mcs, name, bases, attrs)\n\n        # Collect fields\n        fields = {}\n        for key, value in attrs.items():\n            if isinstance(value, Field):\n                fields[key] = value\n\n        # Store fields on class\n        attrs['_fields'] = fields\n\n        return super().__new__(mcs, name, bases, attrs)\n\nclass Field:\n    def __init__(self, field_type):\n        self.field_type = field_type\n\nclass Model(metaclass=ModelMeta):\n    pass\n\nclass User(Model):\n    name = Field(str)\n    age = Field(int)\n    email = Field(str)\n\nprint(User._fields)  # {'name': <Field>, 'age': <Field>, 'email': <Field>}\n\n# Validation metaclass\nclass ValidatedMeta(type):\n    def __new__(mcs, name, bases, attrs):\n        # Ensure all methods have docstrings\n        for key, value in attrs.items():\n            if callable(value) and not key.startswith('__'):\n                if not value.__doc__:\n                    raise ValueError(f\"Method {key} must have a docstring\")\n\n        return super().__new__(mcs, name, bases, attrs)\n\nclass ValidatedClass(metaclass=ValidatedMeta):\n    def documented_method(self):\n        \"\"\"This method has documentation\"\"\"\n        pass\n\n    # def undocumented_method(self):\n    #     pass  # Would raise ValueError\n\n# __init_subclass__ (simpler alternative to metaclasses in Python 3.6+)\nclass PluginBase:\n    subclasses = []\n\n    def __init_subclass__(cls, **kwargs):\n        super().__init_subclass__(**kwargs)\n        cls.subclasses.append(cls)\n\nclass Plugin1(PluginBase):\n    pass\n\nclass Plugin2(PluginBase):\n    pass\n\nprint(PluginBase.subclasses)  # [Plugin1, Plugin2]\n\n# Abstract Base Class using metaclass\nfrom abc import ABCMeta, abstractmethod\n\nclass Animal(metaclass=ABCMeta):\n    @abstractmethod\n    def speak(self):\n        pass\n\n# animal = Animal()  # TypeError: Can't instantiate abstract class\n\nclass Dog(Animal):\n    def speak(self):\n        return \"Woof!\"\n\ndog = Dog()\nprint(dog.speak())\n\n# When to use metaclasses:\n# 1. Framework development (Django ORM)\n# 2. API wrappers\n# 3. Class validation\n# 4. Singleton patterns\n# 5. Plugin systems\n#\n# When NOT to use:\n# - Regular application code\n# - When __init_subclass__ suffices\n# - When decorators can solve the problem\n# - When it makes code harder to understand"
  }
];
